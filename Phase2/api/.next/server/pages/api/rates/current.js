"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/rates/current";
exports.ids = ["pages/api/rates/current"];
exports.modules = {

/***/ "ioredis":
/*!**************************!*\
  !*** external "ioredis" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "node-cache":
/*!*****************************!*\
  !*** external "node-cache" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node-cache");

/***/ }),

/***/ "rate-limiter-flexible":
/*!****************************************!*\
  !*** external "rate-limiter-flexible" ***!
  \****************************************/
/***/ ((module) => {

module.exports = require("rate-limiter-flexible");

/***/ }),

/***/ "@vercel/kv":
/*!*****************************!*\
  !*** external "@vercel/kv" ***!
  \*****************************/
/***/ ((module) => {

module.exports = import("@vercel/kv");;

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

module.exports = import("uuid");;

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Frates%2Fcurrent&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Frates%2Fcurrent.ts&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Frates%2Fcurrent&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Frates%2Fcurrent.ts&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_rates_current_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/rates/current.ts */ \"(api)/./pages/api/rates/current.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_rates_current_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_rates_current_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_rates_current_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_rates_current_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/rates/current\",\n        pathname: \"/api/rates/current\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_rates_current_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRnJhdGVzJTJGY3VycmVudCZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTJGYXBpJTJGcmF0ZXMlMkZjdXJyZW50LnRzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNMO0FBQzFEO0FBQ3lEO0FBQ3pEO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyx3REFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMsd0RBQVE7QUFDcEM7QUFDTyx3QkFBd0IsZ0hBQW1CO0FBQ2xEO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVELHFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxlYXBlcmZ4L2FwaS8/NjcyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXMvYXBpL3JhdGVzL2N1cnJlbnQudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9yYXRlcy9jdXJyZW50XCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvcmF0ZXMvY3VycmVudFwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Frates%2Fcurrent&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Frates%2Fcurrent.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/database.ts":
/*!*************************!*\
  !*** ./lib/database.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DatabaseService: () => (/* binding */ DatabaseService),\n/* harmony export */   database: () => (/* binding */ database),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _vercel_kv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vercel/kv */ \"@vercel/kv\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-cache */ \"node-cache\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_1__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_vercel_kv__WEBPACK_IMPORTED_MODULE_0__]);\n_vercel_kv__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * Database Service for LeaperFX Backend\n * Supports Vercel KV, Upstash Redis, and fallback to memory storage\n */ \n\nclass DatabaseService {\n    constructor(){\n        this.memoryCache = new (node_cache__WEBPACK_IMPORTED_MODULE_1___default())({\n            stdTTL: 300,\n            checkperiod: 60,\n            useClones: false\n        });\n        this.isKVAvailable = !!(process.env.KV_URL || process.env.KV_REST_API_URL);\n        this.isRedisAvailable = !!(process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN);\n        console.log(\"[Database] KV Available:\", this.isKVAvailable);\n        console.log(\"[Database] Redis Available:\", this.isRedisAvailable);\n    }\n    static getInstance() {\n        if (!DatabaseService.instance) {\n            DatabaseService.instance = new DatabaseService();\n        }\n        return DatabaseService.instance;\n    }\n    /**\n   * Get a value from storage\n   */ async get(key) {\n        try {\n            // Try Vercel KV first\n            if (this.isKVAvailable) {\n                try {\n                    const value = await _vercel_kv__WEBPACK_IMPORTED_MODULE_0__.kv.get(key);\n                    if (value !== null) {\n                        return value;\n                    }\n                } catch (error) {\n                    console.warn(\"[Database] KV get error:\", error);\n                }\n            }\n            // Try Redis second\n            if (this.isRedisAvailable) {\n                try {\n                    const Redis = __webpack_require__(/*! ioredis */ \"ioredis\");\n                    const redis = new Redis({\n                        host: new URL(process.env.UPSTASH_REDIS_REST_URL).hostname,\n                        port: parseInt(new URL(process.env.UPSTASH_REDIS_REST_URL).port) || 6379,\n                        password: process.env.UPSTASH_REDIS_REST_TOKEN,\n                        tls: {}\n                    });\n                    const value = await redis.get(key);\n                    await redis.quit();\n                    if (value) {\n                        return JSON.parse(value);\n                    }\n                } catch (error) {\n                    console.warn(\"[Database] Redis get error:\", error);\n                }\n            }\n            // Fallback to memory cache\n            return this.memoryCache.get(key) || null;\n        } catch (error) {\n            console.error(\"[Database] Get error:\", error);\n            return null;\n        }\n    }\n    /**\n   * Set a value in storage\n   */ async set(key, value, ttl) {\n        try {\n            // Try Vercel KV first\n            if (this.isKVAvailable) {\n                try {\n                    if (ttl) {\n                        await _vercel_kv__WEBPACK_IMPORTED_MODULE_0__.kv.setex(key, ttl, value);\n                    } else {\n                        await _vercel_kv__WEBPACK_IMPORTED_MODULE_0__.kv.set(key, value);\n                    }\n                    return true;\n                } catch (error) {\n                    console.warn(\"[Database] KV set error:\", error);\n                }\n            }\n            // Try Redis second\n            if (this.isRedisAvailable) {\n                try {\n                    const Redis = __webpack_require__(/*! ioredis */ \"ioredis\");\n                    const redis = new Redis({\n                        host: new URL(process.env.UPSTASH_REDIS_REST_URL).hostname,\n                        port: parseInt(new URL(process.env.UPSTASH_REDIS_REST_URL).port) || 6379,\n                        password: process.env.UPSTASH_REDIS_REST_TOKEN,\n                        tls: {}\n                    });\n                    const serialized = JSON.stringify(value);\n                    if (ttl) {\n                        await redis.setex(key, ttl, serialized);\n                    } else {\n                        await redis.set(key, serialized);\n                    }\n                    await redis.quit();\n                    return true;\n                } catch (error) {\n                    console.warn(\"[Database] Redis set error:\", error);\n                }\n            }\n            // Fallback to memory cache\n            if (ttl) {\n                this.memoryCache.set(key, value, ttl);\n            } else {\n                this.memoryCache.set(key, value);\n            }\n            return true;\n        } catch (error) {\n            console.error(\"[Database] Set error:\", error);\n            return false;\n        }\n    }\n    /**\n   * Delete a value from storage\n   */ async delete(key) {\n        try {\n            let deleted = false;\n            // Try Vercel KV first\n            if (this.isKVAvailable) {\n                try {\n                    await _vercel_kv__WEBPACK_IMPORTED_MODULE_0__.kv.del(key);\n                    deleted = true;\n                } catch (error) {\n                    console.warn(\"[Database] KV delete error:\", error);\n                }\n            }\n            // Try Redis second\n            if (this.isRedisAvailable) {\n                try {\n                    const Redis = __webpack_require__(/*! ioredis */ \"ioredis\");\n                    const redis = new Redis({\n                        host: new URL(process.env.UPSTASH_REDIS_REST_URL).hostname,\n                        port: parseInt(new URL(process.env.UPSTASH_REDIS_REST_URL).port) || 6379,\n                        password: process.env.UPSTASH_REDIS_REST_TOKEN,\n                        tls: {}\n                    });\n                    await redis.del(key);\n                    await redis.quit();\n                    deleted = true;\n                } catch (error) {\n                    console.warn(\"[Database] Redis delete error:\", error);\n                }\n            }\n            // Always delete from memory cache\n            this.memoryCache.del(key);\n            return true;\n        } catch (error) {\n            console.error(\"[Database] Delete error:\", error);\n            return false;\n        }\n    }\n    /**\n   * Check if key exists\n   */ async exists(key) {\n        try {\n            // Check KV first\n            if (this.isKVAvailable) {\n                try {\n                    const value = await _vercel_kv__WEBPACK_IMPORTED_MODULE_0__.kv.get(key);\n                    if (value !== null) return true;\n                } catch (error) {\n                    console.warn(\"[Database] KV exists error:\", error);\n                }\n            }\n            // Check Redis\n            if (this.isRedisAvailable) {\n                try {\n                    const Redis = __webpack_require__(/*! ioredis */ \"ioredis\");\n                    const redis = new Redis({\n                        host: new URL(process.env.UPSTASH_REDIS_REST_URL).hostname,\n                        port: parseInt(new URL(process.env.UPSTASH_REDIS_REST_URL).port) || 6379,\n                        password: process.env.UPSTASH_REDIS_REST_TOKEN,\n                        tls: {}\n                    });\n                    const exists = await redis.exists(key);\n                    await redis.quit();\n                    if (exists) return true;\n                } catch (error) {\n                    console.warn(\"[Database] Redis exists error:\", error);\n                }\n            }\n            // Check memory cache\n            return this.memoryCache.has(key);\n        } catch (error) {\n            console.error(\"[Database] Exists error:\", error);\n            return false;\n        }\n    }\n    /**\n   * Get all keys matching a pattern\n   */ async keys(pattern) {\n        try {\n            const keys = new Set();\n            // Get from KV (limited pattern support)\n            if (this.isKVAvailable) {\n                try {\n                // KV doesn't support pattern matching, so we'll skip this for now\n                // In a real implementation, you'd maintain an index of keys\n                } catch (error) {\n                    console.warn(\"[Database] KV keys error:\", error);\n                }\n            }\n            // Get from Redis\n            if (this.isRedisAvailable) {\n                try {\n                    const Redis = __webpack_require__(/*! ioredis */ \"ioredis\");\n                    const redis = new Redis({\n                        host: new URL(process.env.UPSTASH_REDIS_REST_URL).hostname,\n                        port: parseInt(new URL(process.env.UPSTASH_REDIS_REST_URL).port) || 6379,\n                        password: process.env.UPSTASH_REDIS_REST_TOKEN,\n                        tls: {}\n                    });\n                    const redisKeys = await redis.keys(pattern);\n                    redisKeys.forEach((key)=>keys.add(key));\n                    await redis.quit();\n                } catch (error) {\n                    console.warn(\"[Database] Redis keys error:\", error);\n                }\n            }\n            // Get from memory cache\n            const memoryKeys = this.memoryCache.keys();\n            const regex = new RegExp(pattern.replace(/\\*/g, \".*\").replace(/\\?/g, \".\"));\n            memoryKeys.forEach((key)=>{\n                if (regex.test(key)) {\n                    keys.add(key);\n                }\n            });\n            return Array.from(keys);\n        } catch (error) {\n            console.error(\"[Database] Keys error:\", error);\n            return [];\n        }\n    }\n    /**\n   * Increment a counter\n   */ async increment(key, by = 1) {\n        try {\n            // Try KV first\n            if (this.isKVAvailable) {\n                try {\n                    return await _vercel_kv__WEBPACK_IMPORTED_MODULE_0__.kv.incr(key);\n                } catch (error) {\n                    console.warn(\"[Database] KV increment error:\", error);\n                }\n            }\n            // Try Redis\n            if (this.isRedisAvailable) {\n                try {\n                    const Redis = __webpack_require__(/*! ioredis */ \"ioredis\");\n                    const redis = new Redis({\n                        host: new URL(process.env.UPSTASH_REDIS_REST_URL).hostname,\n                        port: parseInt(new URL(process.env.UPSTASH_REDIS_REST_URL).port) || 6379,\n                        password: process.env.UPSTASH_REDIS_REST_TOKEN,\n                        tls: {}\n                    });\n                    const result = await redis.incrby(key, by);\n                    await redis.quit();\n                    return result;\n                } catch (error) {\n                    console.warn(\"[Database] Redis increment error:\", error);\n                }\n            }\n            // Fallback to memory cache\n            const current = this.memoryCache.get(key) || 0;\n            const newValue = current + by;\n            this.memoryCache.set(key, newValue);\n            return newValue;\n        } catch (error) {\n            console.error(\"[Database] Increment error:\", error);\n            return 0;\n        }\n    }\n    /**\n   * Set with expiration\n   */ async setex(key, seconds, value) {\n        return this.set(key, value, seconds);\n    }\n    /**\n   * Hash operations for complex data structures\n   */ async hset(key, field, value) {\n        try {\n            const hash = await this.get(key) || {};\n            hash[field] = value;\n            return this.set(key, hash);\n        } catch (error) {\n            console.error(\"[Database] Hash set error:\", error);\n            return false;\n        }\n    }\n    async hget(key, field) {\n        try {\n            const hash = await this.get(key);\n            return hash ? hash[field] : null;\n        } catch (error) {\n            console.error(\"[Database] Hash get error:\", error);\n            return null;\n        }\n    }\n    async hgetall(key) {\n        try {\n            return await this.get(key);\n        } catch (error) {\n            console.error(\"[Database] Hash get all error:\", error);\n            return null;\n        }\n    }\n    /**\n   * List operations\n   */ async lpush(key, value) {\n        try {\n            const list = await this.get(key) || [];\n            list.unshift(value);\n            await this.set(key, list);\n            return list.length;\n        } catch (error) {\n            console.error(\"[Database] List push error:\", error);\n            return 0;\n        }\n    }\n    async lrange(key, start, stop) {\n        try {\n            const list = await this.get(key) || [];\n            return list.slice(start, stop === -1 ? undefined : stop + 1);\n        } catch (error) {\n            console.error(\"[Database] List range error:\", error);\n            return [];\n        }\n    }\n    /**\n   * Configuration-specific methods\n   */ async getConfiguration(key) {\n        return this.get(`config:${key}`);\n    }\n    async setConfiguration(config) {\n        return this.set(`config:${config.key}`, config);\n    }\n    async getAllConfigurations() {\n        try {\n            const keys = await this.keys(\"config:*\");\n            const configs = [];\n            for (const key of keys){\n                const config = await this.get(key);\n                if (config) {\n                    configs.push(config);\n                }\n            }\n            return configs;\n        } catch (error) {\n            console.error(\"[Database] Get all configurations error:\", error);\n            return [];\n        }\n    }\n    async getProfile(id) {\n        return this.get(`profile:${id}`);\n    }\n    async setProfile(profile) {\n        return this.set(`profile:${profile.id}`, profile);\n    }\n    async getAllProfiles() {\n        try {\n            const keys = await this.keys(\"profile:*\");\n            const profiles = [];\n            for (const key of keys){\n                const profile = await this.get(key);\n                if (profile) {\n                    profiles.push(profile);\n                }\n            }\n            return profiles;\n        } catch (error) {\n            console.error(\"[Database] Get all profiles error:\", error);\n            return [];\n        }\n    }\n    /**\n   * Health check\n   */ async healthCheck() {\n        const details = {\n            memory: true,\n            kv: false,\n            redis: false\n        };\n        let healthyCount = 1; // Memory is always available\n        // Test KV\n        if (this.isKVAvailable) {\n            try {\n                await _vercel_kv__WEBPACK_IMPORTED_MODULE_0__.kv.set(\"health_check\", Date.now());\n                await _vercel_kv__WEBPACK_IMPORTED_MODULE_0__.kv.get(\"health_check\");\n                details.kv = true;\n                healthyCount++;\n            } catch (error) {\n                details.kvError = error instanceof Error ? error.message : \"Unknown error\";\n            }\n        }\n        // Test Redis\n        if (this.isRedisAvailable) {\n            try {\n                const Redis = __webpack_require__(/*! ioredis */ \"ioredis\");\n                const redis = new Redis({\n                    host: new URL(process.env.UPSTASH_REDIS_REST_URL).hostname,\n                    port: parseInt(new URL(process.env.UPSTASH_REDIS_REST_URL).port) || 6379,\n                    password: process.env.UPSTASH_REDIS_REST_TOKEN,\n                    tls: {}\n                });\n                await redis.set(\"health_check\", Date.now());\n                await redis.get(\"health_check\");\n                await redis.quit();\n                details.redis = true;\n                healthyCount++;\n            } catch (error) {\n                details.redisError = error instanceof Error ? error.message : \"Unknown error\";\n            }\n        }\n        const totalServices = 1 + (this.isKVAvailable ? 1 : 0) + (this.isRedisAvailable ? 1 : 0);\n        const status = healthyCount === totalServices ? \"healthy\" : healthyCount > 0 ? \"degraded\" : \"unhealthy\";\n        return {\n            status,\n            details\n        };\n    }\n}\nconst database = DatabaseService.getInstance();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (database);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvZGF0YWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRStCO0FBQ0c7QUFHNUIsTUFBTUU7SUFNWEMsYUFBYztRQUNaLElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUlILG1EQUFTQSxDQUFDO1lBQy9CSSxRQUFRO1lBQ1JDLGFBQWE7WUFDYkMsV0FBVztRQUNiO1FBRUEsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQyxDQUFFQyxDQUFBQSxRQUFRQyxHQUFHLENBQUNDLE1BQU0sSUFBSUYsUUFBUUMsR0FBRyxDQUFDRSxlQUFlO1FBQ3pFLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFFSixDQUFBQSxRQUFRQyxHQUFHLENBQUNJLHNCQUFzQixJQUFJTCxRQUFRQyxHQUFHLENBQUNLLHdCQUF3QjtRQUVyR0MsUUFBUUMsR0FBRyxDQUFDLDRCQUE0QixJQUFJLENBQUNULGFBQWE7UUFDMURRLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0IsSUFBSSxDQUFDSixnQkFBZ0I7SUFDbEU7SUFFQSxPQUFPSyxjQUErQjtRQUNwQyxJQUFJLENBQUNoQixnQkFBZ0JpQixRQUFRLEVBQUU7WUFDN0JqQixnQkFBZ0JpQixRQUFRLEdBQUcsSUFBSWpCO1FBQ2pDO1FBQ0EsT0FBT0EsZ0JBQWdCaUIsUUFBUTtJQUNqQztJQUVBOztHQUVDLEdBQ0QsTUFBTUMsSUFBYUMsR0FBVyxFQUFxQjtRQUNqRCxJQUFJO1lBQ0Ysc0JBQXNCO1lBQ3RCLElBQUksSUFBSSxDQUFDYixhQUFhLEVBQUU7Z0JBQ3RCLElBQUk7b0JBQ0YsTUFBTWMsUUFBUSxNQUFNdEIsMENBQUVBLENBQUNvQixHQUFHLENBQUNDO29CQUMzQixJQUFJQyxVQUFVLE1BQU07d0JBQ2xCLE9BQU9BO29CQUNUO2dCQUNGLEVBQUUsT0FBT0MsT0FBTztvQkFDZFAsUUFBUVEsSUFBSSxDQUFDLDRCQUE0QkQ7Z0JBQzNDO1lBQ0Y7WUFFQSxtQkFBbUI7WUFDbkIsSUFBSSxJQUFJLENBQUNWLGdCQUFnQixFQUFFO2dCQUN6QixJQUFJO29CQUNGLE1BQU1ZLFFBQVFDLG1CQUFPQSxDQUFDO29CQUN0QixNQUFNQyxRQUFRLElBQUlGLE1BQU07d0JBQ3RCRyxNQUFNLElBQUlDLElBQUlwQixRQUFRQyxHQUFHLENBQUNJLHNCQUFzQixFQUFHZ0IsUUFBUTt3QkFDM0RDLE1BQU1DLFNBQVMsSUFBSUgsSUFBSXBCLFFBQVFDLEdBQUcsQ0FBQ0ksc0JBQXNCLEVBQUdpQixJQUFJLEtBQUs7d0JBQ3JFRSxVQUFVeEIsUUFBUUMsR0FBRyxDQUFDSyx3QkFBd0I7d0JBQzlDbUIsS0FBSyxDQUFDO29CQUNSO29CQUVBLE1BQU1aLFFBQVEsTUFBTUssTUFBTVAsR0FBRyxDQUFDQztvQkFDOUIsTUFBTU0sTUFBTVEsSUFBSTtvQkFFaEIsSUFBSWIsT0FBTzt3QkFDVCxPQUFPYyxLQUFLQyxLQUFLLENBQUNmO29CQUNwQjtnQkFDRixFQUFFLE9BQU9DLE9BQU87b0JBQ2RQLFFBQVFRLElBQUksQ0FBQywrQkFBK0JEO2dCQUM5QztZQUNGO1lBRUEsMkJBQTJCO1lBQzNCLE9BQU8sSUFBSSxDQUFDbkIsV0FBVyxDQUFDZ0IsR0FBRyxDQUFDQyxRQUFhO1FBQzNDLEVBQUUsT0FBT0UsT0FBTztZQUNkUCxRQUFRTyxLQUFLLENBQUMseUJBQXlCQTtZQUN2QyxPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTWUsSUFBSWpCLEdBQVcsRUFBRUMsS0FBVSxFQUFFaUIsR0FBWSxFQUFvQjtRQUNqRSxJQUFJO1lBQ0Ysc0JBQXNCO1lBQ3RCLElBQUksSUFBSSxDQUFDL0IsYUFBYSxFQUFFO2dCQUN0QixJQUFJO29CQUNGLElBQUkrQixLQUFLO3dCQUNQLE1BQU12QywwQ0FBRUEsQ0FBQ3dDLEtBQUssQ0FBQ25CLEtBQUtrQixLQUFLakI7b0JBQzNCLE9BQU87d0JBQ0wsTUFBTXRCLDBDQUFFQSxDQUFDc0MsR0FBRyxDQUFDakIsS0FBS0M7b0JBQ3BCO29CQUNBLE9BQU87Z0JBQ1QsRUFBRSxPQUFPQyxPQUFPO29CQUNkUCxRQUFRUSxJQUFJLENBQUMsNEJBQTRCRDtnQkFDM0M7WUFDRjtZQUVBLG1CQUFtQjtZQUNuQixJQUFJLElBQUksQ0FBQ1YsZ0JBQWdCLEVBQUU7Z0JBQ3pCLElBQUk7b0JBQ0YsTUFBTVksUUFBUUMsbUJBQU9BLENBQUM7b0JBQ3RCLE1BQU1DLFFBQVEsSUFBSUYsTUFBTTt3QkFDdEJHLE1BQU0sSUFBSUMsSUFBSXBCLFFBQVFDLEdBQUcsQ0FBQ0ksc0JBQXNCLEVBQUdnQixRQUFRO3dCQUMzREMsTUFBTUMsU0FBUyxJQUFJSCxJQUFJcEIsUUFBUUMsR0FBRyxDQUFDSSxzQkFBc0IsRUFBR2lCLElBQUksS0FBSzt3QkFDckVFLFVBQVV4QixRQUFRQyxHQUFHLENBQUNLLHdCQUF3Qjt3QkFDOUNtQixLQUFLLENBQUM7b0JBQ1I7b0JBRUEsTUFBTU8sYUFBYUwsS0FBS00sU0FBUyxDQUFDcEI7b0JBQ2xDLElBQUlpQixLQUFLO3dCQUNQLE1BQU1aLE1BQU1hLEtBQUssQ0FBQ25CLEtBQUtrQixLQUFLRTtvQkFDOUIsT0FBTzt3QkFDTCxNQUFNZCxNQUFNVyxHQUFHLENBQUNqQixLQUFLb0I7b0JBQ3ZCO29CQUNBLE1BQU1kLE1BQU1RLElBQUk7b0JBQ2hCLE9BQU87Z0JBQ1QsRUFBRSxPQUFPWixPQUFPO29CQUNkUCxRQUFRUSxJQUFJLENBQUMsK0JBQStCRDtnQkFDOUM7WUFDRjtZQUVBLDJCQUEyQjtZQUMzQixJQUFJZ0IsS0FBSztnQkFDUCxJQUFJLENBQUNuQyxXQUFXLENBQUNrQyxHQUFHLENBQUNqQixLQUFLQyxPQUFPaUI7WUFDbkMsT0FBTztnQkFDTCxJQUFJLENBQUNuQyxXQUFXLENBQUNrQyxHQUFHLENBQUNqQixLQUFLQztZQUM1QjtZQUNBLE9BQU87UUFDVCxFQUFFLE9BQU9DLE9BQU87WUFDZFAsUUFBUU8sS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU1vQixPQUFPdEIsR0FBVyxFQUFvQjtRQUMxQyxJQUFJO1lBQ0YsSUFBSXVCLFVBQVU7WUFFZCxzQkFBc0I7WUFDdEIsSUFBSSxJQUFJLENBQUNwQyxhQUFhLEVBQUU7Z0JBQ3RCLElBQUk7b0JBQ0YsTUFBTVIsMENBQUVBLENBQUM2QyxHQUFHLENBQUN4QjtvQkFDYnVCLFVBQVU7Z0JBQ1osRUFBRSxPQUFPckIsT0FBTztvQkFDZFAsUUFBUVEsSUFBSSxDQUFDLCtCQUErQkQ7Z0JBQzlDO1lBQ0Y7WUFFQSxtQkFBbUI7WUFDbkIsSUFBSSxJQUFJLENBQUNWLGdCQUFnQixFQUFFO2dCQUN6QixJQUFJO29CQUNGLE1BQU1ZLFFBQVFDLG1CQUFPQSxDQUFDO29CQUN0QixNQUFNQyxRQUFRLElBQUlGLE1BQU07d0JBQ3RCRyxNQUFNLElBQUlDLElBQUlwQixRQUFRQyxHQUFHLENBQUNJLHNCQUFzQixFQUFHZ0IsUUFBUTt3QkFDM0RDLE1BQU1DLFNBQVMsSUFBSUgsSUFBSXBCLFFBQVFDLEdBQUcsQ0FBQ0ksc0JBQXNCLEVBQUdpQixJQUFJLEtBQUs7d0JBQ3JFRSxVQUFVeEIsUUFBUUMsR0FBRyxDQUFDSyx3QkFBd0I7d0JBQzlDbUIsS0FBSyxDQUFDO29CQUNSO29CQUVBLE1BQU1QLE1BQU1rQixHQUFHLENBQUN4QjtvQkFDaEIsTUFBTU0sTUFBTVEsSUFBSTtvQkFDaEJTLFVBQVU7Z0JBQ1osRUFBRSxPQUFPckIsT0FBTztvQkFDZFAsUUFBUVEsSUFBSSxDQUFDLGtDQUFrQ0Q7Z0JBQ2pEO1lBQ0Y7WUFFQSxrQ0FBa0M7WUFDbEMsSUFBSSxDQUFDbkIsV0FBVyxDQUFDeUMsR0FBRyxDQUFDeEI7WUFDckIsT0FBTztRQUNULEVBQUUsT0FBT0UsT0FBTztZQUNkUCxRQUFRTyxLQUFLLENBQUMsNEJBQTRCQTtZQUMxQyxPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTXVCLE9BQU96QixHQUFXLEVBQW9CO1FBQzFDLElBQUk7WUFDRixpQkFBaUI7WUFDakIsSUFBSSxJQUFJLENBQUNiLGFBQWEsRUFBRTtnQkFDdEIsSUFBSTtvQkFDRixNQUFNYyxRQUFRLE1BQU10QiwwQ0FBRUEsQ0FBQ29CLEdBQUcsQ0FBQ0M7b0JBQzNCLElBQUlDLFVBQVUsTUFBTSxPQUFPO2dCQUM3QixFQUFFLE9BQU9DLE9BQU87b0JBQ2RQLFFBQVFRLElBQUksQ0FBQywrQkFBK0JEO2dCQUM5QztZQUNGO1lBRUEsY0FBYztZQUNkLElBQUksSUFBSSxDQUFDVixnQkFBZ0IsRUFBRTtnQkFDekIsSUFBSTtvQkFDRixNQUFNWSxRQUFRQyxtQkFBT0EsQ0FBQztvQkFDdEIsTUFBTUMsUUFBUSxJQUFJRixNQUFNO3dCQUN0QkcsTUFBTSxJQUFJQyxJQUFJcEIsUUFBUUMsR0FBRyxDQUFDSSxzQkFBc0IsRUFBR2dCLFFBQVE7d0JBQzNEQyxNQUFNQyxTQUFTLElBQUlILElBQUlwQixRQUFRQyxHQUFHLENBQUNJLHNCQUFzQixFQUFHaUIsSUFBSSxLQUFLO3dCQUNyRUUsVUFBVXhCLFFBQVFDLEdBQUcsQ0FBQ0ssd0JBQXdCO3dCQUM5Q21CLEtBQUssQ0FBQztvQkFDUjtvQkFFQSxNQUFNWSxTQUFTLE1BQU1uQixNQUFNbUIsTUFBTSxDQUFDekI7b0JBQ2xDLE1BQU1NLE1BQU1RLElBQUk7b0JBQ2hCLElBQUlXLFFBQVEsT0FBTztnQkFDckIsRUFBRSxPQUFPdkIsT0FBTztvQkFDZFAsUUFBUVEsSUFBSSxDQUFDLGtDQUFrQ0Q7Z0JBQ2pEO1lBQ0Y7WUFFQSxxQkFBcUI7WUFDckIsT0FBTyxJQUFJLENBQUNuQixXQUFXLENBQUMyQyxHQUFHLENBQUMxQjtRQUM5QixFQUFFLE9BQU9FLE9BQU87WUFDZFAsUUFBUU8sS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU15QixLQUFLQyxPQUFlLEVBQXFCO1FBQzdDLElBQUk7WUFDRixNQUFNRCxPQUFvQixJQUFJRTtZQUU5Qix3Q0FBd0M7WUFDeEMsSUFBSSxJQUFJLENBQUMxQyxhQUFhLEVBQUU7Z0JBQ3RCLElBQUk7Z0JBQ0Ysa0VBQWtFO2dCQUNsRSw0REFBNEQ7Z0JBQzlELEVBQUUsT0FBT2UsT0FBTztvQkFDZFAsUUFBUVEsSUFBSSxDQUFDLDZCQUE2QkQ7Z0JBQzVDO1lBQ0Y7WUFFQSxpQkFBaUI7WUFDakIsSUFBSSxJQUFJLENBQUNWLGdCQUFnQixFQUFFO2dCQUN6QixJQUFJO29CQUNGLE1BQU1ZLFFBQVFDLG1CQUFPQSxDQUFDO29CQUN0QixNQUFNQyxRQUFRLElBQUlGLE1BQU07d0JBQ3RCRyxNQUFNLElBQUlDLElBQUlwQixRQUFRQyxHQUFHLENBQUNJLHNCQUFzQixFQUFHZ0IsUUFBUTt3QkFDM0RDLE1BQU1DLFNBQVMsSUFBSUgsSUFBSXBCLFFBQVFDLEdBQUcsQ0FBQ0ksc0JBQXNCLEVBQUdpQixJQUFJLEtBQUs7d0JBQ3JFRSxVQUFVeEIsUUFBUUMsR0FBRyxDQUFDSyx3QkFBd0I7d0JBQzlDbUIsS0FBSyxDQUFDO29CQUNSO29CQUVBLE1BQU1pQixZQUFZLE1BQU14QixNQUFNcUIsSUFBSSxDQUFDQztvQkFDbkNFLFVBQVVDLE9BQU8sQ0FBQyxDQUFDL0IsTUFBZ0IyQixLQUFLSyxHQUFHLENBQUNoQztvQkFDNUMsTUFBTU0sTUFBTVEsSUFBSTtnQkFDbEIsRUFBRSxPQUFPWixPQUFPO29CQUNkUCxRQUFRUSxJQUFJLENBQUMsZ0NBQWdDRDtnQkFDL0M7WUFDRjtZQUVBLHdCQUF3QjtZQUN4QixNQUFNK0IsYUFBYSxJQUFJLENBQUNsRCxXQUFXLENBQUM0QyxJQUFJO1lBQ3hDLE1BQU1PLFFBQVEsSUFBSUMsT0FBT1AsUUFBUVEsT0FBTyxDQUFDLE9BQU8sTUFBTUEsT0FBTyxDQUFDLE9BQU87WUFDckVILFdBQVdGLE9BQU8sQ0FBQy9CLENBQUFBO2dCQUNqQixJQUFJa0MsTUFBTUcsSUFBSSxDQUFDckMsTUFBTTtvQkFDbkIyQixLQUFLSyxHQUFHLENBQUNoQztnQkFDWDtZQUNGO1lBRUEsT0FBT3NDLE1BQU1DLElBQUksQ0FBQ1o7UUFDcEIsRUFBRSxPQUFPekIsT0FBTztZQUNkUCxRQUFRTyxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QyxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNc0MsVUFBVXhDLEdBQVcsRUFBRXlDLEtBQWEsQ0FBQyxFQUFtQjtRQUM1RCxJQUFJO1lBQ0YsZUFBZTtZQUNmLElBQUksSUFBSSxDQUFDdEQsYUFBYSxFQUFFO2dCQUN0QixJQUFJO29CQUNGLE9BQU8sTUFBTVIsMENBQUVBLENBQUMrRCxJQUFJLENBQUMxQztnQkFDdkIsRUFBRSxPQUFPRSxPQUFPO29CQUNkUCxRQUFRUSxJQUFJLENBQUMsa0NBQWtDRDtnQkFDakQ7WUFDRjtZQUVBLFlBQVk7WUFDWixJQUFJLElBQUksQ0FBQ1YsZ0JBQWdCLEVBQUU7Z0JBQ3pCLElBQUk7b0JBQ0YsTUFBTVksUUFBUUMsbUJBQU9BLENBQUM7b0JBQ3RCLE1BQU1DLFFBQVEsSUFBSUYsTUFBTTt3QkFDdEJHLE1BQU0sSUFBSUMsSUFBSXBCLFFBQVFDLEdBQUcsQ0FBQ0ksc0JBQXNCLEVBQUdnQixRQUFRO3dCQUMzREMsTUFBTUMsU0FBUyxJQUFJSCxJQUFJcEIsUUFBUUMsR0FBRyxDQUFDSSxzQkFBc0IsRUFBR2lCLElBQUksS0FBSzt3QkFDckVFLFVBQVV4QixRQUFRQyxHQUFHLENBQUNLLHdCQUF3Qjt3QkFDOUNtQixLQUFLLENBQUM7b0JBQ1I7b0JBRUEsTUFBTThCLFNBQVMsTUFBTXJDLE1BQU1zQyxNQUFNLENBQUM1QyxLQUFLeUM7b0JBQ3ZDLE1BQU1uQyxNQUFNUSxJQUFJO29CQUNoQixPQUFPNkI7Z0JBQ1QsRUFBRSxPQUFPekMsT0FBTztvQkFDZFAsUUFBUVEsSUFBSSxDQUFDLHFDQUFxQ0Q7Z0JBQ3BEO1lBQ0Y7WUFFQSwyQkFBMkI7WUFDM0IsTUFBTTJDLFVBQVUsSUFBSSxDQUFDOUQsV0FBVyxDQUFDZ0IsR0FBRyxDQUFDQyxRQUFrQjtZQUN2RCxNQUFNOEMsV0FBV0QsVUFBVUo7WUFDM0IsSUFBSSxDQUFDMUQsV0FBVyxDQUFDa0MsR0FBRyxDQUFDakIsS0FBSzhDO1lBQzFCLE9BQU9BO1FBQ1QsRUFBRSxPQUFPNUMsT0FBTztZQUNkUCxRQUFRTyxLQUFLLENBQUMsK0JBQStCQTtZQUM3QyxPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTWlCLE1BQU1uQixHQUFXLEVBQUUrQyxPQUFlLEVBQUU5QyxLQUFVLEVBQW9CO1FBQ3RFLE9BQU8sSUFBSSxDQUFDZ0IsR0FBRyxDQUFDakIsS0FBS0MsT0FBTzhDO0lBQzlCO0lBRUE7O0dBRUMsR0FDRCxNQUFNQyxLQUFLaEQsR0FBVyxFQUFFaUQsS0FBYSxFQUFFaEQsS0FBVSxFQUFvQjtRQUNuRSxJQUFJO1lBQ0YsTUFBTWlELE9BQU8sTUFBTSxJQUFJLENBQUNuRCxHQUFHLENBQUNDLFFBQVEsQ0FBQztZQUNyQ2tELElBQUksQ0FBQ0QsTUFBTSxHQUFHaEQ7WUFDZCxPQUFPLElBQUksQ0FBQ2dCLEdBQUcsQ0FBQ2pCLEtBQUtrRDtRQUN2QixFQUFFLE9BQU9oRCxPQUFPO1lBQ2RQLFFBQVFPLEtBQUssQ0FBQyw4QkFBOEJBO1lBQzVDLE9BQU87UUFDVDtJQUNGO0lBRUEsTUFBTWlELEtBQUtuRCxHQUFXLEVBQUVpRCxLQUFhLEVBQWdCO1FBQ25ELElBQUk7WUFDRixNQUFNQyxPQUFPLE1BQU0sSUFBSSxDQUFDbkQsR0FBRyxDQUFDQztZQUM1QixPQUFPa0QsT0FBT0EsSUFBSSxDQUFDRCxNQUFNLEdBQUc7UUFDOUIsRUFBRSxPQUFPL0MsT0FBTztZQUNkUCxRQUFRTyxLQUFLLENBQUMsOEJBQThCQTtZQUM1QyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE1BQU1rRCxRQUFRcEQsR0FBVyxFQUF1QztRQUM5RCxJQUFJO1lBQ0YsT0FBTyxNQUFNLElBQUksQ0FBQ0QsR0FBRyxDQUFDQztRQUN4QixFQUFFLE9BQU9FLE9BQU87WUFDZFAsUUFBUU8sS0FBSyxDQUFDLGtDQUFrQ0E7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU1tRCxNQUFNckQsR0FBVyxFQUFFQyxLQUFVLEVBQW1CO1FBQ3BELElBQUk7WUFDRixNQUFNcUQsT0FBTyxNQUFNLElBQUksQ0FBQ3ZELEdBQUcsQ0FBQ0MsUUFBUSxFQUFFO1lBQ3RDc0QsS0FBS0MsT0FBTyxDQUFDdEQ7WUFDYixNQUFNLElBQUksQ0FBQ2dCLEdBQUcsQ0FBQ2pCLEtBQUtzRDtZQUNwQixPQUFPQSxLQUFLRSxNQUFNO1FBQ3BCLEVBQUUsT0FBT3RELE9BQU87WUFDZFAsUUFBUU8sS0FBSyxDQUFDLCtCQUErQkE7WUFDN0MsT0FBTztRQUNUO0lBQ0Y7SUFFQSxNQUFNdUQsT0FBT3pELEdBQVcsRUFBRTBELEtBQWEsRUFBRUMsSUFBWSxFQUFrQjtRQUNyRSxJQUFJO1lBQ0YsTUFBTUwsT0FBTyxNQUFNLElBQUksQ0FBQ3ZELEdBQUcsQ0FBQ0MsUUFBUSxFQUFFO1lBQ3RDLE9BQU9zRCxLQUFLTSxLQUFLLENBQUNGLE9BQU9DLFNBQVMsQ0FBQyxJQUFJRSxZQUFZRixPQUFPO1FBQzVELEVBQUUsT0FBT3pELE9BQU87WUFDZFAsUUFBUU8sS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTTRELGlCQUFpQjlELEdBQVcsRUFBc0M7UUFDdEUsT0FBTyxJQUFJLENBQUNELEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRUMsSUFBSSxDQUFDO0lBQ2pDO0lBRUEsTUFBTStELGlCQUFpQkMsTUFBMEIsRUFBb0I7UUFDbkUsT0FBTyxJQUFJLENBQUMvQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUrQyxPQUFPaEUsR0FBRyxDQUFDLENBQUMsRUFBRWdFO0lBQzFDO0lBRUEsTUFBTUMsdUJBQXNEO1FBQzFELElBQUk7WUFDRixNQUFNdEMsT0FBTyxNQUFNLElBQUksQ0FBQ0EsSUFBSSxDQUFDO1lBQzdCLE1BQU11QyxVQUFnQyxFQUFFO1lBRXhDLEtBQUssTUFBTWxFLE9BQU8yQixLQUFNO2dCQUN0QixNQUFNcUMsU0FBUyxNQUFNLElBQUksQ0FBQ2pFLEdBQUcsQ0FBQ0M7Z0JBQzlCLElBQUlnRSxRQUFRO29CQUNWRSxRQUFRQyxJQUFJLENBQUNIO2dCQUNmO1lBQ0Y7WUFFQSxPQUFPRTtRQUNULEVBQUUsT0FBT2hFLE9BQU87WUFDZFAsUUFBUU8sS0FBSyxDQUFDLDRDQUE0Q0E7WUFDMUQsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBLE1BQU1rRSxXQUFXQyxFQUFVLEVBQXdDO1FBQ2pFLE9BQU8sSUFBSSxDQUFDdEUsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFc0UsR0FBRyxDQUFDO0lBQ2pDO0lBRUEsTUFBTUMsV0FBV0MsT0FBNkIsRUFBb0I7UUFDaEUsT0FBTyxJQUFJLENBQUN0RCxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUVzRCxRQUFRRixFQUFFLENBQUMsQ0FBQyxFQUFFRTtJQUMzQztJQUVBLE1BQU1DLGlCQUFrRDtRQUN0RCxJQUFJO1lBQ0YsTUFBTTdDLE9BQU8sTUFBTSxJQUFJLENBQUNBLElBQUksQ0FBQztZQUM3QixNQUFNOEMsV0FBbUMsRUFBRTtZQUUzQyxLQUFLLE1BQU16RSxPQUFPMkIsS0FBTTtnQkFDdEIsTUFBTTRDLFVBQVUsTUFBTSxJQUFJLENBQUN4RSxHQUFHLENBQUNDO2dCQUMvQixJQUFJdUUsU0FBUztvQkFDWEUsU0FBU04sSUFBSSxDQUFDSTtnQkFDaEI7WUFDRjtZQUVBLE9BQU9FO1FBQ1QsRUFBRSxPQUFPdkUsT0FBTztZQUNkUCxRQUFRTyxLQUFLLENBQUMsc0NBQXNDQTtZQUNwRCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNd0UsY0FBeUQ7UUFDN0QsTUFBTUMsVUFBZTtZQUNuQkMsUUFBUTtZQUNSakcsSUFBSTtZQUNKMkIsT0FBTztRQUNUO1FBRUEsSUFBSXVFLGVBQWUsR0FBRyw2QkFBNkI7UUFFbkQsVUFBVTtRQUNWLElBQUksSUFBSSxDQUFDMUYsYUFBYSxFQUFFO1lBQ3RCLElBQUk7Z0JBQ0YsTUFBTVIsMENBQUVBLENBQUNzQyxHQUFHLENBQUMsZ0JBQWdCNkQsS0FBS0MsR0FBRztnQkFDckMsTUFBTXBHLDBDQUFFQSxDQUFDb0IsR0FBRyxDQUFDO2dCQUNiNEUsUUFBUWhHLEVBQUUsR0FBRztnQkFDYmtHO1lBQ0YsRUFBRSxPQUFPM0UsT0FBTztnQkFDZHlFLFFBQVFLLE9BQU8sR0FBRzlFLGlCQUFpQitFLFFBQVEvRSxNQUFNZ0YsT0FBTyxHQUFHO1lBQzdEO1FBQ0Y7UUFFQSxhQUFhO1FBQ2IsSUFBSSxJQUFJLENBQUMxRixnQkFBZ0IsRUFBRTtZQUN6QixJQUFJO2dCQUNGLE1BQU1ZLFFBQVFDLG1CQUFPQSxDQUFDO2dCQUN0QixNQUFNQyxRQUFRLElBQUlGLE1BQU07b0JBQ3RCRyxNQUFNLElBQUlDLElBQUlwQixRQUFRQyxHQUFHLENBQUNJLHNCQUFzQixFQUFHZ0IsUUFBUTtvQkFDM0RDLE1BQU1DLFNBQVMsSUFBSUgsSUFBSXBCLFFBQVFDLEdBQUcsQ0FBQ0ksc0JBQXNCLEVBQUdpQixJQUFJLEtBQUs7b0JBQ3JFRSxVQUFVeEIsUUFBUUMsR0FBRyxDQUFDSyx3QkFBd0I7b0JBQzlDbUIsS0FBSyxDQUFDO2dCQUNSO2dCQUVBLE1BQU1QLE1BQU1XLEdBQUcsQ0FBQyxnQkFBZ0I2RCxLQUFLQyxHQUFHO2dCQUN4QyxNQUFNekUsTUFBTVAsR0FBRyxDQUFDO2dCQUNoQixNQUFNTyxNQUFNUSxJQUFJO2dCQUNoQjZELFFBQVFyRSxLQUFLLEdBQUc7Z0JBQ2hCdUU7WUFDRixFQUFFLE9BQU8zRSxPQUFPO2dCQUNkeUUsUUFBUVEsVUFBVSxHQUFHakYsaUJBQWlCK0UsUUFBUS9FLE1BQU1nRixPQUFPLEdBQUc7WUFDaEU7UUFDRjtRQUVBLE1BQU1FLGdCQUFnQixJQUFLLEtBQUksQ0FBQ2pHLGFBQWEsR0FBRyxJQUFJLEtBQU0sS0FBSSxDQUFDSyxnQkFBZ0IsR0FBRyxJQUFJO1FBQ3RGLE1BQU02RixTQUFTUixpQkFBaUJPLGdCQUFnQixZQUNqQ1AsZUFBZSxJQUFJLGFBQWE7UUFFL0MsT0FBTztZQUFFUTtZQUFRVjtRQUFRO0lBQzNCO0FBQ0Y7QUFFTyxNQUFNVyxXQUFXekcsZ0JBQWdCZ0IsV0FBVyxHQUFHO0FBQ3RELGlFQUFleUYsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BsZWFwZXJmeC9hcGkvLi9saWIvZGF0YWJhc2UudHM/NGQ0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERhdGFiYXNlIFNlcnZpY2UgZm9yIExlYXBlckZYIEJhY2tlbmRcbiAqIFN1cHBvcnRzIFZlcmNlbCBLViwgVXBzdGFzaCBSZWRpcywgYW5kIGZhbGxiYWNrIHRvIG1lbW9yeSBzdG9yYWdlXG4gKi9cblxuaW1wb3J0IHsga3YgfSBmcm9tICdAdmVyY2VsL2t2JztcbmltcG9ydCBOb2RlQ2FjaGUgZnJvbSAnbm9kZS1jYWNoZSc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uVmFsdWUsIENvbmZpZ3VyYXRpb25Qcm9maWxlIH0gZnJvbSAnLi4vdHlwZXMvYXBpJztcblxuZXhwb3J0IGNsYXNzIERhdGFiYXNlU2VydmljZSB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBEYXRhYmFzZVNlcnZpY2U7XG4gIHByaXZhdGUgbWVtb3J5Q2FjaGU6IE5vZGVDYWNoZTtcbiAgcHJpdmF0ZSBpc0tWQXZhaWxhYmxlOiBib29sZWFuO1xuICBwcml2YXRlIGlzUmVkaXNBdmFpbGFibGU6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tZW1vcnlDYWNoZSA9IG5ldyBOb2RlQ2FjaGUoe1xuICAgICAgc3RkVFRMOiAzMDAsIC8vIDUgbWludXRlcyBkZWZhdWx0IFRUTFxuICAgICAgY2hlY2twZXJpb2Q6IDYwLCAvLyBDaGVjayBmb3IgZXhwaXJlZCBrZXlzIGV2ZXJ5IG1pbnV0ZVxuICAgICAgdXNlQ2xvbmVzOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIHRoaXMuaXNLVkF2YWlsYWJsZSA9ICEhKHByb2Nlc3MuZW52LktWX1VSTCB8fCBwcm9jZXNzLmVudi5LVl9SRVNUX0FQSV9VUkwpO1xuICAgIHRoaXMuaXNSZWRpc0F2YWlsYWJsZSA9ICEhKHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkwgJiYgcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOKTtcblxuICAgIGNvbnNvbGUubG9nKCdbRGF0YWJhc2VdIEtWIEF2YWlsYWJsZTonLCB0aGlzLmlzS1ZBdmFpbGFibGUpO1xuICAgIGNvbnNvbGUubG9nKCdbRGF0YWJhc2VdIFJlZGlzIEF2YWlsYWJsZTonLCB0aGlzLmlzUmVkaXNBdmFpbGFibGUpO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IERhdGFiYXNlU2VydmljZSB7XG4gICAgaWYgKCFEYXRhYmFzZVNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIERhdGFiYXNlU2VydmljZS5pbnN0YW5jZSA9IG5ldyBEYXRhYmFzZVNlcnZpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIERhdGFiYXNlU2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YWx1ZSBmcm9tIHN0b3JhZ2VcbiAgICovXG4gIGFzeW5jIGdldDxUID0gYW55PihrZXk6IHN0cmluZyk6IFByb21pc2U8VCB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IFZlcmNlbCBLViBmaXJzdFxuICAgICAgaWYgKHRoaXMuaXNLVkF2YWlsYWJsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQga3YuZ2V0KGtleSk7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgYXMgVDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbRGF0YWJhc2VdIEtWIGdldCBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IFJlZGlzIHNlY29uZFxuICAgICAgaWYgKHRoaXMuaXNSZWRpc0F2YWlsYWJsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IFJlZGlzID0gcmVxdWlyZSgnaW9yZWRpcycpO1xuICAgICAgICAgIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzKHtcbiAgICAgICAgICAgIGhvc3Q6IG5ldyBVUkwocHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1VSTCEpLmhvc3RuYW1lLFxuICAgICAgICAgICAgcG9ydDogcGFyc2VJbnQobmV3IFVSTChwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMISkucG9ydCkgfHwgNjM3OSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVE9LRU4sXG4gICAgICAgICAgICB0bHM6IHt9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCByZWRpcy5nZXQoa2V5KTtcbiAgICAgICAgICBhd2FpdCByZWRpcy5xdWl0KCk7XG5cbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKSBhcyBUO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1tEYXRhYmFzZV0gUmVkaXMgZ2V0IGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGYWxsYmFjayB0byBtZW1vcnkgY2FjaGVcbiAgICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmdldChrZXkpIGFzIFQgfHwgbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0RhdGFiYXNlXSBHZXQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGluIHN0b3JhZ2VcbiAgICovXG4gIGFzeW5jIHNldChrZXk6IHN0cmluZywgdmFsdWU6IGFueSwgdHRsPzogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSBWZXJjZWwgS1YgZmlyc3RcbiAgICAgIGlmICh0aGlzLmlzS1ZBdmFpbGFibGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHRsKSB7XG4gICAgICAgICAgICBhd2FpdCBrdi5zZXRleChrZXksIHR0bCwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBrdi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0RhdGFiYXNlXSBLViBzZXQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSBSZWRpcyBzZWNvbmRcbiAgICAgIGlmICh0aGlzLmlzUmVkaXNBdmFpbGFibGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBSZWRpcyA9IHJlcXVpcmUoJ2lvcmVkaXMnKTtcbiAgICAgICAgICBjb25zdCByZWRpcyA9IG5ldyBSZWRpcyh7XG4gICAgICAgICAgICBob3N0OiBuZXcgVVJMKHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkwhKS5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6IHBhcnNlSW50KG5ldyBVUkwocHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1VSTCEpLnBvcnQpIHx8IDYzNzksXG4gICAgICAgICAgICBwYXNzd29yZDogcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOLFxuICAgICAgICAgICAgdGxzOiB7fSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHR0bCkge1xuICAgICAgICAgICAgYXdhaXQgcmVkaXMuc2V0ZXgoa2V5LCB0dGwsIHNlcmlhbGl6ZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCByZWRpcy5zZXQoa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgcmVkaXMucXVpdCgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0RhdGFiYXNlXSBSZWRpcyBzZXQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZhbGxiYWNrIHRvIG1lbW9yeSBjYWNoZVxuICAgICAgaWYgKHR0bCkge1xuICAgICAgICB0aGlzLm1lbW9yeUNhY2hlLnNldChrZXksIHZhbHVlLCB0dGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZW1vcnlDYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0RhdGFiYXNlXSBTZXQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSB2YWx1ZSBmcm9tIHN0b3JhZ2VcbiAgICovXG4gIGFzeW5jIGRlbGV0ZShrZXk6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBUcnkgVmVyY2VsIEtWIGZpcnN0XG4gICAgICBpZiAodGhpcy5pc0tWQXZhaWxhYmxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQga3YuZGVsKGtleSk7XG4gICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbRGF0YWJhc2VdIEtWIGRlbGV0ZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IFJlZGlzIHNlY29uZFxuICAgICAgaWYgKHRoaXMuaXNSZWRpc0F2YWlsYWJsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IFJlZGlzID0gcmVxdWlyZSgnaW9yZWRpcycpO1xuICAgICAgICAgIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzKHtcbiAgICAgICAgICAgIGhvc3Q6IG5ldyBVUkwocHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1VSTCEpLmhvc3RuYW1lLFxuICAgICAgICAgICAgcG9ydDogcGFyc2VJbnQobmV3IFVSTChwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMISkucG9ydCkgfHwgNjM3OSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVE9LRU4sXG4gICAgICAgICAgICB0bHM6IHt9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYXdhaXQgcmVkaXMuZGVsKGtleSk7XG4gICAgICAgICAgYXdhaXQgcmVkaXMucXVpdCgpO1xuICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0RhdGFiYXNlXSBSZWRpcyBkZWxldGUgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFsd2F5cyBkZWxldGUgZnJvbSBtZW1vcnkgY2FjaGVcbiAgICAgIHRoaXMubWVtb3J5Q2FjaGUuZGVsKGtleSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0RhdGFiYXNlXSBEZWxldGUgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBrZXkgZXhpc3RzXG4gICAqL1xuICBhc3luYyBleGlzdHMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgS1YgZmlyc3RcbiAgICAgIGlmICh0aGlzLmlzS1ZBdmFpbGFibGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGt2LmdldChrZXkpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbRGF0YWJhc2VdIEtWIGV4aXN0cyBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgUmVkaXNcbiAgICAgIGlmICh0aGlzLmlzUmVkaXNBdmFpbGFibGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBSZWRpcyA9IHJlcXVpcmUoJ2lvcmVkaXMnKTtcbiAgICAgICAgICBjb25zdCByZWRpcyA9IG5ldyBSZWRpcyh7XG4gICAgICAgICAgICBob3N0OiBuZXcgVVJMKHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkwhKS5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6IHBhcnNlSW50KG5ldyBVUkwocHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1VSTCEpLnBvcnQpIHx8IDYzNzksXG4gICAgICAgICAgICBwYXNzd29yZDogcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOLFxuICAgICAgICAgICAgdGxzOiB7fSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IGF3YWl0IHJlZGlzLmV4aXN0cyhrZXkpO1xuICAgICAgICAgIGF3YWl0IHJlZGlzLnF1aXQoKTtcbiAgICAgICAgICBpZiAoZXhpc3RzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1tEYXRhYmFzZV0gUmVkaXMgZXhpc3RzIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBtZW1vcnkgY2FjaGVcbiAgICAgIHJldHVybiB0aGlzLm1lbW9yeUNhY2hlLmhhcyhrZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbRGF0YWJhc2VdIEV4aXN0cyBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwga2V5cyBtYXRjaGluZyBhIHBhdHRlcm5cbiAgICovXG4gIGFzeW5jIGtleXMocGF0dGVybjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gR2V0IGZyb20gS1YgKGxpbWl0ZWQgcGF0dGVybiBzdXBwb3J0KVxuICAgICAgaWYgKHRoaXMuaXNLVkF2YWlsYWJsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEtWIGRvZXNuJ3Qgc3VwcG9ydCBwYXR0ZXJuIG1hdGNoaW5nLCBzbyB3ZSdsbCBza2lwIHRoaXMgZm9yIG5vd1xuICAgICAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91J2QgbWFpbnRhaW4gYW4gaW5kZXggb2Yga2V5c1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0RhdGFiYXNlXSBLViBrZXlzIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBHZXQgZnJvbSBSZWRpc1xuICAgICAgaWYgKHRoaXMuaXNSZWRpc0F2YWlsYWJsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IFJlZGlzID0gcmVxdWlyZSgnaW9yZWRpcycpO1xuICAgICAgICAgIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzKHtcbiAgICAgICAgICAgIGhvc3Q6IG5ldyBVUkwocHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1VSTCEpLmhvc3RuYW1lLFxuICAgICAgICAgICAgcG9ydDogcGFyc2VJbnQobmV3IFVSTChwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMISkucG9ydCkgfHwgNjM3OSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVE9LRU4sXG4gICAgICAgICAgICB0bHM6IHt9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVkaXNLZXlzID0gYXdhaXQgcmVkaXMua2V5cyhwYXR0ZXJuKTtcbiAgICAgICAgICByZWRpc0tleXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IGtleXMuYWRkKGtleSkpO1xuICAgICAgICAgIGF3YWl0IHJlZGlzLnF1aXQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1tEYXRhYmFzZV0gUmVkaXMga2V5cyBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGZyb20gbWVtb3J5IGNhY2hlXG4gICAgICBjb25zdCBtZW1vcnlLZXlzID0gdGhpcy5tZW1vcnlDYWNoZS5rZXlzKCk7XG4gICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9cXCovZywgJy4qJykucmVwbGFjZSgvXFw/L2csICcuJykpO1xuICAgICAgbWVtb3J5S2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChyZWdleC50ZXN0KGtleSkpIHtcbiAgICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oa2V5cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tEYXRhYmFzZV0gS2V5cyBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCBhIGNvdW50ZXJcbiAgICovXG4gIGFzeW5jIGluY3JlbWVudChrZXk6IHN0cmluZywgYnk6IG51bWJlciA9IDEpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgS1YgZmlyc3RcbiAgICAgIGlmICh0aGlzLmlzS1ZBdmFpbGFibGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQga3YuaW5jcihrZXkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0RhdGFiYXNlXSBLViBpbmNyZW1lbnQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSBSZWRpc1xuICAgICAgaWYgKHRoaXMuaXNSZWRpc0F2YWlsYWJsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IFJlZGlzID0gcmVxdWlyZSgnaW9yZWRpcycpO1xuICAgICAgICAgIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzKHtcbiAgICAgICAgICAgIGhvc3Q6IG5ldyBVUkwocHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1VSTCEpLmhvc3RuYW1lLFxuICAgICAgICAgICAgcG9ydDogcGFyc2VJbnQobmV3IFVSTChwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMISkucG9ydCkgfHwgNjM3OSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVE9LRU4sXG4gICAgICAgICAgICB0bHM6IHt9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVkaXMuaW5jcmJ5KGtleSwgYnkpO1xuICAgICAgICAgIGF3YWl0IHJlZGlzLnF1aXQoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0RhdGFiYXNlXSBSZWRpcyBpbmNyZW1lbnQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZhbGxiYWNrIHRvIG1lbW9yeSBjYWNoZVxuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMubWVtb3J5Q2FjaGUuZ2V0KGtleSkgYXMgbnVtYmVyIHx8IDA7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGN1cnJlbnQgKyBieTtcbiAgICAgIHRoaXMubWVtb3J5Q2FjaGUuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbRGF0YWJhc2VdIEluY3JlbWVudCBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdpdGggZXhwaXJhdGlvblxuICAgKi9cbiAgYXN5bmMgc2V0ZXgoa2V5OiBzdHJpbmcsIHNlY29uZHM6IG51bWJlciwgdmFsdWU6IGFueSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLnNldChrZXksIHZhbHVlLCBzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYXNoIG9wZXJhdGlvbnMgZm9yIGNvbXBsZXggZGF0YSBzdHJ1Y3R1cmVzXG4gICAqL1xuICBhc3luYyBoc2V0KGtleTogc3RyaW5nLCBmaWVsZDogc3RyaW5nLCB2YWx1ZTogYW55KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLmdldChrZXkpIHx8IHt9O1xuICAgICAgaGFzaFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzLnNldChrZXksIGhhc2gpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbRGF0YWJhc2VdIEhhc2ggc2V0IGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBoZ2V0KGtleTogc3RyaW5nLCBmaWVsZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gaGFzaCA/IGhhc2hbZmllbGRdIDogbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0RhdGFiYXNlXSBIYXNoIGdldCBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBoZ2V0YWxsKGtleTogc3RyaW5nKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0RhdGFiYXNlXSBIYXNoIGdldCBhbGwgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgb3BlcmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgbHB1c2goa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsaXN0ID0gYXdhaXQgdGhpcy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgIGxpc3QudW5zaGlmdCh2YWx1ZSk7XG4gICAgICBhd2FpdCB0aGlzLnNldChrZXksIGxpc3QpO1xuICAgICAgcmV0dXJuIGxpc3QubGVuZ3RoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbRGF0YWJhc2VdIExpc3QgcHVzaCBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBscmFuZ2Uoa2V5OiBzdHJpbmcsIHN0YXJ0OiBudW1iZXIsIHN0b3A6IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbGlzdCA9IGF3YWl0IHRoaXMuZ2V0KGtleSkgfHwgW107XG4gICAgICByZXR1cm4gbGlzdC5zbGljZShzdGFydCwgc3RvcCA9PT0gLTEgPyB1bmRlZmluZWQgOiBzdG9wICsgMSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tEYXRhYmFzZV0gTGlzdCByYW5nZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyYXRpb24tc3BlY2lmaWMgbWV0aG9kc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlndXJhdGlvbihrZXk6IHN0cmluZyk6IFByb21pc2U8Q29uZmlndXJhdGlvblZhbHVlIHwgbnVsbD4ge1xuICAgIHJldHVybiB0aGlzLmdldChgY29uZmlnOiR7a2V5fWApO1xuICB9XG5cbiAgYXN5bmMgc2V0Q29uZmlndXJhdGlvbihjb25maWc6IENvbmZpZ3VyYXRpb25WYWx1ZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLnNldChgY29uZmlnOiR7Y29uZmlnLmtleX1gLCBjb25maWcpO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsQ29uZmlndXJhdGlvbnMoKTogUHJvbWlzZTxDb25maWd1cmF0aW9uVmFsdWVbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzID0gYXdhaXQgdGhpcy5rZXlzKCdjb25maWc6KicpO1xuICAgICAgY29uc3QgY29uZmlnczogQ29uZmlndXJhdGlvblZhbHVlW10gPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBhd2FpdCB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgY29uZmlncy5wdXNoKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbmZpZ3M7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tEYXRhYmFzZV0gR2V0IGFsbCBjb25maWd1cmF0aW9ucyBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0UHJvZmlsZShpZDogc3RyaW5nKTogUHJvbWlzZTxDb25maWd1cmF0aW9uUHJvZmlsZSB8IG51bGw+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQoYHByb2ZpbGU6JHtpZH1gKTtcbiAgfVxuXG4gIGFzeW5jIHNldFByb2ZpbGUocHJvZmlsZTogQ29uZmlndXJhdGlvblByb2ZpbGUpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5zZXQoYHByb2ZpbGU6JHtwcm9maWxlLmlkfWAsIHByb2ZpbGUpO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWxsUHJvZmlsZXMoKTogUHJvbWlzZTxDb25maWd1cmF0aW9uUHJvZmlsZVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCB0aGlzLmtleXMoJ3Byb2ZpbGU6KicpO1xuICAgICAgY29uc3QgcHJvZmlsZXM6IENvbmZpZ3VyYXRpb25Qcm9maWxlW10gPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgICBwcm9maWxlcy5wdXNoKHByb2ZpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9maWxlcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0RhdGFiYXNlXSBHZXQgYWxsIHByb2ZpbGVzIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVhbHRoIGNoZWNrXG4gICAqL1xuICBhc3luYyBoZWFsdGhDaGVjaygpOiBQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmc7IGRldGFpbHM6IGFueSB9PiB7XG4gICAgY29uc3QgZGV0YWlsczogYW55ID0ge1xuICAgICAgbWVtb3J5OiB0cnVlLFxuICAgICAga3Y6IGZhbHNlLFxuICAgICAgcmVkaXM6IGZhbHNlLFxuICAgIH07XG5cbiAgICBsZXQgaGVhbHRoeUNvdW50ID0gMTsgLy8gTWVtb3J5IGlzIGFsd2F5cyBhdmFpbGFibGVcblxuICAgIC8vIFRlc3QgS1ZcbiAgICBpZiAodGhpcy5pc0tWQXZhaWxhYmxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBrdi5zZXQoJ2hlYWx0aF9jaGVjaycsIERhdGUubm93KCkpO1xuICAgICAgICBhd2FpdCBrdi5nZXQoJ2hlYWx0aF9jaGVjaycpO1xuICAgICAgICBkZXRhaWxzLmt2ID0gdHJ1ZTtcbiAgICAgICAgaGVhbHRoeUNvdW50Kys7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZXRhaWxzLmt2RXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUZXN0IFJlZGlzXG4gICAgaWYgKHRoaXMuaXNSZWRpc0F2YWlsYWJsZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUmVkaXMgPSByZXF1aXJlKCdpb3JlZGlzJyk7XG4gICAgICAgIGNvbnN0IHJlZGlzID0gbmV3IFJlZGlzKHtcbiAgICAgICAgICBob3N0OiBuZXcgVVJMKHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkwhKS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiBwYXJzZUludChuZXcgVVJMKHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkwhKS5wb3J0KSB8fCA2Mzc5LFxuICAgICAgICAgIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVE9LRU4sXG4gICAgICAgICAgdGxzOiB7fSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgcmVkaXMuc2V0KCdoZWFsdGhfY2hlY2snLCBEYXRlLm5vdygpKTtcbiAgICAgICAgYXdhaXQgcmVkaXMuZ2V0KCdoZWFsdGhfY2hlY2snKTtcbiAgICAgICAgYXdhaXQgcmVkaXMucXVpdCgpO1xuICAgICAgICBkZXRhaWxzLnJlZGlzID0gdHJ1ZTtcbiAgICAgICAgaGVhbHRoeUNvdW50Kys7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZXRhaWxzLnJlZGlzRXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0b3RhbFNlcnZpY2VzID0gMSArICh0aGlzLmlzS1ZBdmFpbGFibGUgPyAxIDogMCkgKyAodGhpcy5pc1JlZGlzQXZhaWxhYmxlID8gMSA6IDApO1xuICAgIGNvbnN0IHN0YXR1cyA9IGhlYWx0aHlDb3VudCA9PT0gdG90YWxTZXJ2aWNlcyA/ICdoZWFsdGh5JyA6XG4gICAgICAgICAgICAgICAgICAgaGVhbHRoeUNvdW50ID4gMCA/ICdkZWdyYWRlZCcgOiAndW5oZWFsdGh5JztcblxuICAgIHJldHVybiB7IHN0YXR1cywgZGV0YWlscyB9O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkYXRhYmFzZSA9IERhdGFiYXNlU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuZXhwb3J0IGRlZmF1bHQgZGF0YWJhc2U7Il0sIm5hbWVzIjpbImt2IiwiTm9kZUNhY2hlIiwiRGF0YWJhc2VTZXJ2aWNlIiwiY29uc3RydWN0b3IiLCJtZW1vcnlDYWNoZSIsInN0ZFRUTCIsImNoZWNrcGVyaW9kIiwidXNlQ2xvbmVzIiwiaXNLVkF2YWlsYWJsZSIsInByb2Nlc3MiLCJlbnYiLCJLVl9VUkwiLCJLVl9SRVNUX0FQSV9VUkwiLCJpc1JlZGlzQXZhaWxhYmxlIiwiVVBTVEFTSF9SRURJU19SRVNUX1VSTCIsIlVQU1RBU0hfUkVESVNfUkVTVF9UT0tFTiIsImNvbnNvbGUiLCJsb2ciLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0Iiwia2V5IiwidmFsdWUiLCJlcnJvciIsIndhcm4iLCJSZWRpcyIsInJlcXVpcmUiLCJyZWRpcyIsImhvc3QiLCJVUkwiLCJob3N0bmFtZSIsInBvcnQiLCJwYXJzZUludCIsInBhc3N3b3JkIiwidGxzIiwicXVpdCIsIkpTT04iLCJwYXJzZSIsInNldCIsInR0bCIsInNldGV4Iiwic2VyaWFsaXplZCIsInN0cmluZ2lmeSIsImRlbGV0ZSIsImRlbGV0ZWQiLCJkZWwiLCJleGlzdHMiLCJoYXMiLCJrZXlzIiwicGF0dGVybiIsIlNldCIsInJlZGlzS2V5cyIsImZvckVhY2giLCJhZGQiLCJtZW1vcnlLZXlzIiwicmVnZXgiLCJSZWdFeHAiLCJyZXBsYWNlIiwidGVzdCIsIkFycmF5IiwiZnJvbSIsImluY3JlbWVudCIsImJ5IiwiaW5jciIsInJlc3VsdCIsImluY3JieSIsImN1cnJlbnQiLCJuZXdWYWx1ZSIsInNlY29uZHMiLCJoc2V0IiwiZmllbGQiLCJoYXNoIiwiaGdldCIsImhnZXRhbGwiLCJscHVzaCIsImxpc3QiLCJ1bnNoaWZ0IiwibGVuZ3RoIiwibHJhbmdlIiwic3RhcnQiLCJzdG9wIiwic2xpY2UiLCJ1bmRlZmluZWQiLCJnZXRDb25maWd1cmF0aW9uIiwic2V0Q29uZmlndXJhdGlvbiIsImNvbmZpZyIsImdldEFsbENvbmZpZ3VyYXRpb25zIiwiY29uZmlncyIsInB1c2giLCJnZXRQcm9maWxlIiwiaWQiLCJzZXRQcm9maWxlIiwicHJvZmlsZSIsImdldEFsbFByb2ZpbGVzIiwicHJvZmlsZXMiLCJoZWFsdGhDaGVjayIsImRldGFpbHMiLCJtZW1vcnkiLCJoZWFsdGh5Q291bnQiLCJEYXRlIiwibm93Iiwia3ZFcnJvciIsIkVycm9yIiwibWVzc2FnZSIsInJlZGlzRXJyb3IiLCJ0b3RhbFNlcnZpY2VzIiwic3RhdHVzIiwiZGF0YWJhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/database.ts\n");

/***/ }),

/***/ "(api)/./lib/rate-engine.ts":
/*!****************************!*\
  !*** ./lib/rate-engine.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RateEngine: () => (/* binding */ RateEngine),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   rateEngine: () => (/* binding */ rateEngine)\n/* harmony export */ });\n/* harmony import */ var _database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./database */ \"(api)/./lib/database.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_database__WEBPACK_IMPORTED_MODULE_0__]);\n_database__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * Rate Engine - Core rate calculation and management system\n * Handles real-time rate calculations, spread management, and threshold monitoring\n */ \nclass RateEngine {\n    constructor(){\n        this.isRunning = false;\n        this.rates = new Map();\n        this.thresholds = new Map();\n        this.alerts = [];\n        this.lastUpdate = 0;\n        this.sources = new Set([\n            \"polygon\",\n            \"twelvedata\",\n            \"coinbase\"\n        ]);\n        this.subscribers = new Set();\n        this.config = {\n            defaultSpread: 0.02,\n            minSpread: 0.005,\n            maxSpread: 0.1,\n            volatilityFactor: 0.1,\n            liquidityFactor: 0.05,\n            updateFrequency: 30000\n        };\n    }\n    static getInstance() {\n        if (!RateEngine.instance) {\n            RateEngine.instance = new RateEngine();\n        }\n        return RateEngine.instance;\n    }\n    /**\n   * Start the rate engine\n   */ async start() {\n        if (this.isRunning) {\n            console.log(\"[RateEngine] Already running\");\n            return;\n        }\n        console.log(\"[RateEngine] Starting rate engine...\");\n        try {\n            // Load existing rates and thresholds from database\n            await this.loadConfiguration();\n            // Start update cycle\n            this.updateInterval = setInterval(()=>{\n                this.updateRates().catch((error)=>{\n                    console.error(\"[RateEngine] Update cycle error:\", error);\n                });\n            }, this.config.updateFrequency);\n            // Initial update\n            await this.updateRates();\n            this.isRunning = true;\n            console.log(\"[RateEngine] Started successfully\");\n        } catch (error) {\n            console.error(\"[RateEngine] Failed to start:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Stop the rate engine\n   */ stop() {\n        if (!this.isRunning) {\n            return;\n        }\n        console.log(\"[RateEngine] Stopping rate engine...\");\n        if (this.updateInterval) {\n            clearInterval(this.updateInterval);\n            this.updateInterval = undefined;\n        }\n        this.isRunning = false;\n        console.log(\"[RateEngine] Stopped\");\n    }\n    /**\n   * Load configuration from database\n   */ async loadConfiguration() {\n        try {\n            // Load existing rates\n            const ratesData = await _database__WEBPACK_IMPORTED_MODULE_0__.database.get(\"rates:all\");\n            if (ratesData) {\n                const rates = JSON.parse(ratesData);\n                rates.forEach((rate)=>{\n                    this.rates.set(rate.baseCurrency + rate.targetCurrency, rate);\n                });\n            }\n            // Load thresholds\n            const thresholdsData = await _database__WEBPACK_IMPORTED_MODULE_0__.database.get(\"thresholds:all\");\n            if (thresholdsData) {\n                const thresholds = JSON.parse(thresholdsData);\n                thresholds.forEach((threshold)=>{\n                    this.thresholds.set(threshold.currencyPair, threshold);\n                });\n            }\n            // Load config\n            const configData = await _database__WEBPACK_IMPORTED_MODULE_0__.database.get(\"rate_engine:config\");\n            if (configData) {\n                this.config = {\n                    ...this.config,\n                    ...JSON.parse(configData)\n                };\n            }\n        } catch (error) {\n            console.error(\"[RateEngine] Error loading configuration:\", error);\n        }\n    }\n    /**\n   * Save configuration to database\n   */ async saveConfiguration() {\n        try {\n            const rates = Array.from(this.rates.values());\n            const thresholds = Array.from(this.thresholds.values());\n            await Promise.all([\n                _database__WEBPACK_IMPORTED_MODULE_0__.database.setex(\"rates:all\", 3600, JSON.stringify(rates)),\n                _database__WEBPACK_IMPORTED_MODULE_0__.database.setex(\"thresholds:all\", 3600, JSON.stringify(thresholds)),\n                _database__WEBPACK_IMPORTED_MODULE_0__.database.setex(\"rate_engine:config\", 3600, JSON.stringify(this.config))\n            ]);\n        } catch (error) {\n            console.error(\"[RateEngine] Error saving configuration:\", error);\n        }\n    }\n    /**\n   * Update all rates from market data\n   */ async updateRates() {\n        const startTime = Date.now();\n        try {\n            console.log(\"[RateEngine] Updating rates...\");\n            // Get market data for all tracked currency pairs\n            const currencyPairs = this.getCurrencyPairs();\n            for (const pair of currencyPairs){\n                await this.updateRateForPair(pair);\n            }\n            // Save updated rates\n            await this.saveConfiguration();\n            // Check thresholds and generate alerts\n            this.checkThresholds();\n            this.lastUpdate = Date.now();\n            const duration = this.lastUpdate - startTime;\n            console.log(`[RateEngine] Updated ${currencyPairs.length} rates in ${duration}ms`);\n        } catch (error) {\n            console.error(\"[RateEngine] Error updating rates:\", error);\n        }\n    }\n    /**\n   * Update rate for a specific currency pair\n   */ async updateRateForPair(pair) {\n        try {\n            const [base, target] = pair.split(\"/\");\n            // Get market data for this pair\n            const marketData = await this.getMarketData(base, target);\n            if (!marketData) {\n                console.warn(`[RateEngine] No market data for ${pair}`);\n                return;\n            }\n            // Calculate rate with spread\n            const rate = this.calculateRateWithSpread(marketData, pair);\n            // Update rate in memory\n            this.rates.set(pair.replace(\"/\", \"\"), rate);\n            // Cache individual rate\n            await _database__WEBPACK_IMPORTED_MODULE_0__.database.setex(`rate:${pair.replace(\"/\", \"\")}`, 60, JSON.stringify(rate));\n        } catch (error) {\n            console.error(`[RateEngine] Error updating rate for ${pair}:`, error);\n        }\n    }\n    /**\n   * Get market data for currency pair\n   */ async getMarketData(base, target) {\n        try {\n            // Try different sources\n            for (const source of this.sources){\n                const data = await this.fetchFromSource(source, base, target);\n                if (data) {\n                    return data;\n                }\n            }\n            return null;\n        } catch (error) {\n            console.error(`[RateEngine] Error getting market data for ${base}/${target}:`, error);\n            return null;\n        }\n    }\n    /**\n   * Fetch data from specific source\n   */ async fetchFromSource(source, base, target) {\n        try {\n            switch(source){\n                case \"coinbase\":\n                    return await this.fetchCoinbaseData(base, target);\n                case \"polygon\":\n                    return await this.fetchPolygonData(base, target);\n                case \"twelvedata\":\n                    return await this.fetchTwelveDataData(base, target);\n                default:\n                    return null;\n            }\n        } catch (error) {\n            console.error(`[RateEngine] Error fetching from ${source}:`, error);\n            return null;\n        }\n    }\n    /**\n   * Fetch Coinbase data\n   */ async fetchCoinbaseData(base, target) {\n        try {\n            const pair = `${base}-${target}`;\n            const response = await fetch(`https://api.exchange.coinbase.com/products/${pair}/ticker`);\n            if (!response.ok) {\n                return null;\n            }\n            const data = await response.json();\n            return {\n                symbol: pair,\n                price: parseFloat(data.price),\n                timestamp: Date.now(),\n                bid: parseFloat(data.bid),\n                ask: parseFloat(data.ask),\n                volume: parseFloat(data.volume),\n                source: \"coinbase\"\n            };\n        } catch (error) {\n            return null;\n        }\n    }\n    /**\n   * Fetch Polygon data\n   */ async fetchPolygonData(base, target) {\n        // Implementation for Polygon API\n        // This would require API key from environment\n        return null;\n    }\n    /**\n   * Fetch TwelveData data\n   */ async fetchTwelveDataData(base, target) {\n        // Implementation for TwelveData API\n        // This would require API key from environment\n        return null;\n    }\n    /**\n   * Calculate rate with spread\n   */ calculateRateWithSpread(marketData, pair) {\n        const threshold = this.thresholds.get(pair);\n        const baseSpread = threshold ? (threshold.minSpread + threshold.maxSpread) / 2 : this.config.defaultSpread;\n        // Calculate volatility-adjusted spread\n        const volatilitySpread = this.calculateVolatilitySpread(marketData);\n        const finalSpread = Math.max(Math.min(baseSpread + volatilitySpread, this.config.maxSpread), this.config.minSpread);\n        const buyRate = marketData.price * (1 + finalSpread / 2);\n        const sellRate = marketData.price * (1 - finalSpread / 2);\n        return {\n            id: `${pair}_${Date.now()}`,\n            baseCurrency: pair.split(\"/\")[0] || pair.slice(0, 3),\n            targetCurrency: pair.split(\"/\")[1] || pair.slice(3),\n            rate: marketData.price,\n            spread: finalSpread,\n            buyRate,\n            sellRate,\n            timestamp: marketData.timestamp,\n            source: \"calculated\",\n            isActive: true,\n            lastUpdated: Date.now()\n        };\n    }\n    /**\n   * Calculate volatility-based spread adjustment\n   */ calculateVolatilitySpread(marketData) {\n        if (!marketData.changePercent24h) {\n            return 0;\n        }\n        const volatility = Math.abs(marketData.changePercent24h / 100);\n        return volatility * this.config.volatilityFactor;\n    }\n    /**\n   * Check thresholds and generate alerts\n   */ checkThresholds() {\n        for (const [pair, threshold] of this.thresholds){\n            const rate = this.rates.get(pair.replace(\"/\", \"\"));\n            if (!rate) continue;\n            // Check spread thresholds\n            if (rate.spread < threshold.minSpread || rate.spread > threshold.maxSpread) {\n                this.generateAlert({\n                    id: `alert_${Date.now()}_${pair}`,\n                    currencyPair: pair,\n                    alertType: \"threshold_breach\",\n                    message: `Spread ${(rate.spread * 100).toFixed(2)}% outside threshold range ${(threshold.minSpread * 100).toFixed(2)}%-${(threshold.maxSpread * 100).toFixed(2)}%`,\n                    severity: \"medium\",\n                    timestamp: Date.now(),\n                    acknowledged: false\n                });\n            }\n            // Check rate freshness\n            const ageMinutes = (Date.now() - rate.lastUpdated) / (1000 * 60);\n            if (ageMinutes > 5) {\n                this.generateAlert({\n                    id: `alert_${Date.now()}_stale_${pair}`,\n                    currencyPair: pair,\n                    alertType: \"rate_stale\",\n                    message: `Rate for ${pair} is ${ageMinutes.toFixed(1)} minutes old`,\n                    severity: ageMinutes > 15 ? \"high\" : \"medium\",\n                    timestamp: Date.now(),\n                    acknowledged: false\n                });\n            }\n        }\n    }\n    /**\n   * Generate alert\n   */ generateAlert(alert) {\n        this.alerts.push(alert);\n        console.warn(`[RateEngine] Alert: ${alert.message}`);\n        // Keep only last 100 alerts\n        if (this.alerts.length > 100) {\n            this.alerts = this.alerts.slice(-100);\n        }\n    }\n    /**\n   * Get all currency pairs being tracked\n   */ getCurrencyPairs() {\n        // Default pairs - this could be configurable\n        return [\n            \"USD/CAD\",\n            \"EUR/USD\",\n            \"GBP/USD\",\n            \"USD/JPY\",\n            \"AUD/USD\",\n            \"USD/CHF\",\n            \"BTC/USD\",\n            \"ETH/USD\",\n            \"BTC/CAD\",\n            \"ETH/CAD\"\n        ];\n    }\n    // Public API methods\n    /**\n   * Get current rate for currency pair\n   */ getRate(currencyPair) {\n        return this.rates.get(currencyPair.replace(\"/\", \"\")) || null;\n    }\n    /**\n   * Get all current rates\n   */ getAllRates() {\n        return Array.from(this.rates.values());\n    }\n    /**\n   * Update rate manually (for store owners)\n   */ async updateRateManually(request) {\n        const pair = request.currencyPair.replace(\"/\", \"\");\n        const existingRate = this.rates.get(pair);\n        if (!existingRate) {\n            throw new Error(`Rate not found for ${request.currencyPair}`);\n        }\n        const updatedRate = {\n            ...existingRate,\n            spread: request.spread || existingRate.spread,\n            buyRate: request.buyRate || existingRate.buyRate,\n            sellRate: request.sellRate || existingRate.sellRate,\n            source: request.source,\n            lastUpdated: Date.now(),\n            storeId: request.storeId\n        };\n        // Validate the manual rate\n        if (updatedRate.spread < this.config.minSpread || updatedRate.spread > this.config.maxSpread) {\n            throw new Error(`Spread ${(updatedRate.spread * 100).toFixed(2)}% outside allowed range ${(this.config.minSpread * 100).toFixed(2)}%-${(this.config.maxSpread * 100).toFixed(2)}%`);\n        }\n        this.rates.set(pair, updatedRate);\n        // Save to database\n        await _database__WEBPACK_IMPORTED_MODULE_0__.database.setex(`rate:${pair}`, 3600, JSON.stringify(updatedRate));\n        return updatedRate;\n    }\n    /**\n   * Add rate threshold\n   */ async addThreshold(threshold) {\n        this.thresholds.set(threshold.currencyPair, threshold);\n        await this.saveConfiguration();\n    }\n    /**\n   * Get engine status\n   */ getStatus() {\n        return {\n            isRunning: this.isRunning,\n            lastUpdate: this.lastUpdate,\n            activeSources: Array.from(this.sources),\n            activeSubscriptions: this.subscribers.size,\n            rateCount: this.rates.size,\n            alertCount: this.alerts.length,\n            lockCount: 0,\n            performance: {\n                avgUpdateTime: 0,\n                maxUpdateTime: 0,\n                errorRate: 0\n            }\n        };\n    }\n    /**\n   * Subscribe to rate updates\n   */ subscribe(clientId) {\n        this.subscribers.add(clientId);\n    }\n    /**\n   * Unsubscribe from rate updates\n   */ unsubscribe(clientId) {\n        this.subscribers.delete(clientId);\n    }\n    /**\n   * Get recent alerts\n   */ getAlerts(limit = 50) {\n        return this.alerts.slice(-limit);\n    }\n}\nconst rateEngine = RateEngine.getInstance();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rateEngine);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ3ZDLE9BQU87WUFDdENxSCxxQkFBcUIsSUFBSSxDQUFDbkgsV0FBVyxDQUFDb0gsSUFBSTtZQUMxQ0MsV0FBVyxJQUFJLENBQUM1SCxLQUFLLENBQUMySCxJQUFJO1lBQzFCRSxZQUFZLElBQUksQ0FBQzFILE1BQU0sQ0FBQ3dELE1BQU07WUFDOUJtRSxXQUFXO1lBQ1hDLGFBQWE7Z0JBQ1hDLGVBQWU7Z0JBQ2ZDLGVBQWU7Z0JBQ2ZDLFdBQVc7WUFDYjtRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEQyxVQUFVQyxRQUFnQixFQUFRO1FBQ2hDLElBQUksQ0FBQzdILFdBQVcsQ0FBQzhILEdBQUcsQ0FBQ0Q7SUFDdkI7SUFFQTs7R0FFQyxHQUNERSxZQUFZRixRQUFnQixFQUFRO1FBQ2xDLElBQUksQ0FBQzdILFdBQVcsQ0FBQ2dJLE1BQU0sQ0FBQ0g7SUFDMUI7SUFFQTs7R0FFQyxHQUNESSxVQUFVQyxRQUFnQixFQUFFLEVBQWU7UUFDekMsT0FBTyxJQUFJLENBQUN0SSxNQUFNLENBQUM0RixLQUFLLENBQUMsQ0FBQzBDO0lBQzVCO0FBQ0Y7QUFFTyxNQUFNQyxhQUFhN0ksV0FBV2tCLFdBQVcsR0FBRztBQUNuRCxpRUFBZTJILFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbGVhcGVyZngvYXBpLy4vbGliL3JhdGUtZW5naW5lLnRzPzEwYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSYXRlIEVuZ2luZSAtIENvcmUgcmF0ZSBjYWxjdWxhdGlvbiBhbmQgbWFuYWdlbWVudCBzeXN0ZW1cbiAqIEhhbmRsZXMgcmVhbC10aW1lIHJhdGUgY2FsY3VsYXRpb25zLCBzcHJlYWQgbWFuYWdlbWVudCwgYW5kIHRocmVzaG9sZCBtb25pdG9yaW5nXG4gKi9cblxuaW1wb3J0IHsgRXhjaGFuZ2VSYXRlLCBSYXRlVGhyZXNob2xkLCBSYXRlVXBkYXRlUmVxdWVzdCwgUmF0ZUNhbGN1bGF0aW9uQ29uZmlnLCBSYXRlQWxlcnQsIE1hcmtldFJhdGVEYXRhLCBSYXRlRW5naW5lU3RhdHVzIH0gZnJvbSAnLi4vdHlwZXMvcmF0ZXMnO1xuaW1wb3J0IHsgTWFya2V0RGF0YVBvaW50LCBGb3JleFJhdGUsIENyeXB0b1ByaWNlIH0gZnJvbSAnLi4vdHlwZXMvbWFya2V0LWRhdGEnO1xuaW1wb3J0IHsgZGF0YWJhc2UgfSBmcm9tICcuL2RhdGFiYXNlJztcblxuZXhwb3J0IGNsYXNzIFJhdGVFbmdpbmUge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUmF0ZUVuZ2luZTtcbiAgcHJpdmF0ZSBpc1J1bm5pbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSB1cGRhdGVJbnRlcnZhbD86IE5vZGVKUy5UaW1lb3V0O1xuICBwcml2YXRlIHJhdGVzOiBNYXA8c3RyaW5nLCBFeGNoYW5nZVJhdGU+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHRocmVzaG9sZHM6IE1hcDxzdHJpbmcsIFJhdGVUaHJlc2hvbGQ+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGFsZXJ0czogUmF0ZUFsZXJ0W10gPSBbXTtcbiAgcHJpdmF0ZSBjb25maWc6IFJhdGVDYWxjdWxhdGlvbkNvbmZpZztcbiAgcHJpdmF0ZSBsYXN0VXBkYXRlOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIHNvdXJjZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChbJ3BvbHlnb24nLCAndHdlbHZlZGF0YScsICdjb2luYmFzZSddKTtcbiAgcHJpdmF0ZSBzdWJzY3JpYmVyczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBkZWZhdWx0U3ByZWFkOiAwLjAyLCAvLyAyJVxuICAgICAgbWluU3ByZWFkOiAwLjAwNSwgLy8gMC41JVxuICAgICAgbWF4U3ByZWFkOiAwLjEsIC8vIDEwJVxuICAgICAgdm9sYXRpbGl0eUZhY3RvcjogMC4xLFxuICAgICAgbGlxdWlkaXR5RmFjdG9yOiAwLjA1LFxuICAgICAgdXBkYXRlRnJlcXVlbmN5OiAzMDAwMCwgLy8gMzAgc2Vjb25kc1xuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogUmF0ZUVuZ2luZSB7XG4gICAgaWYgKCFSYXRlRW5naW5lLmluc3RhbmNlKSB7XG4gICAgICBSYXRlRW5naW5lLmluc3RhbmNlID0gbmV3IFJhdGVFbmdpbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIFJhdGVFbmdpbmUuaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHJhdGUgZW5naW5lXG4gICAqL1xuICBhc3luYyBzdGFydCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbUmF0ZUVuZ2luZV0gQWxyZWFkeSBydW5uaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tSYXRlRW5naW5lXSBTdGFydGluZyByYXRlIGVuZ2luZS4uLicpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgZXhpc3RpbmcgcmF0ZXMgYW5kIHRocmVzaG9sZHMgZnJvbSBkYXRhYmFzZVxuICAgICAgYXdhaXQgdGhpcy5sb2FkQ29uZmlndXJhdGlvbigpO1xuXG4gICAgICAvLyBTdGFydCB1cGRhdGUgY3ljbGVcbiAgICAgIHRoaXMudXBkYXRlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlUmF0ZXMoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1JhdGVFbmdpbmVdIFVwZGF0ZSBjeWNsZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSwgdGhpcy5jb25maWcudXBkYXRlRnJlcXVlbmN5KTtcblxuICAgICAgLy8gSW5pdGlhbCB1cGRhdGVcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlUmF0ZXMoKTtcblxuICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coJ1tSYXRlRW5naW5lXSBTdGFydGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbUmF0ZUVuZ2luZV0gRmFpbGVkIHRvIHN0YXJ0OicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSByYXRlIGVuZ2luZVxuICAgKi9cbiAgc3RvcCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tSYXRlRW5naW5lXSBTdG9wcGluZyByYXRlIGVuZ2luZS4uLicpO1xuXG4gICAgaWYgKHRoaXMudXBkYXRlSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy51cGRhdGVJbnRlcnZhbCk7XG4gICAgICB0aGlzLnVwZGF0ZUludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgY29uc29sZS5sb2coJ1tSYXRlRW5naW5lXSBTdG9wcGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBjb25maWd1cmF0aW9uIGZyb20gZGF0YWJhc2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbG9hZENvbmZpZ3VyYXRpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgZXhpc3RpbmcgcmF0ZXNcbiAgICAgIGNvbnN0IHJhdGVzRGF0YSA9IGF3YWl0IGRhdGFiYXNlLmdldCgncmF0ZXM6YWxsJyk7XG4gICAgICBpZiAocmF0ZXNEYXRhKSB7XG4gICAgICAgIGNvbnN0IHJhdGVzID0gSlNPTi5wYXJzZShyYXRlc0RhdGEpO1xuICAgICAgICByYXRlcy5mb3JFYWNoKChyYXRlOiBFeGNoYW5nZVJhdGUpID0+IHtcbiAgICAgICAgICB0aGlzLnJhdGVzLnNldChyYXRlLmJhc2VDdXJyZW5jeSArIHJhdGUudGFyZ2V0Q3VycmVuY3ksIHJhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCB0aHJlc2hvbGRzXG4gICAgICBjb25zdCB0aHJlc2hvbGRzRGF0YSA9IGF3YWl0IGRhdGFiYXNlLmdldCgndGhyZXNob2xkczphbGwnKTtcbiAgICAgIGlmICh0aHJlc2hvbGRzRGF0YSkge1xuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gSlNPTi5wYXJzZSh0aHJlc2hvbGRzRGF0YSk7XG4gICAgICAgIHRocmVzaG9sZHMuZm9yRWFjaCgodGhyZXNob2xkOiBSYXRlVGhyZXNob2xkKSA9PiB7XG4gICAgICAgICAgdGhpcy50aHJlc2hvbGRzLnNldCh0aHJlc2hvbGQuY3VycmVuY3lQYWlyLCB0aHJlc2hvbGQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBjb25maWdcbiAgICAgIGNvbnN0IGNvbmZpZ0RhdGEgPSBhd2FpdCBkYXRhYmFzZS5nZXQoJ3JhdGVfZW5naW5lOmNvbmZpZycpO1xuICAgICAgaWYgKGNvbmZpZ0RhdGEpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7IC4uLnRoaXMuY29uZmlnLCAuLi5KU09OLnBhcnNlKGNvbmZpZ0RhdGEpIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tSYXRlRW5naW5lXSBFcnJvciBsb2FkaW5nIGNvbmZpZ3VyYXRpb246JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlIGNvbmZpZ3VyYXRpb24gdG8gZGF0YWJhc2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ3VyYXRpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhdGVzID0gQXJyYXkuZnJvbSh0aGlzLnJhdGVzLnZhbHVlcygpKTtcbiAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSBBcnJheS5mcm9tKHRoaXMudGhyZXNob2xkcy52YWx1ZXMoKSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZGF0YWJhc2Uuc2V0ZXgoJ3JhdGVzOmFsbCcsIDM2MDAsIEpTT04uc3RyaW5naWZ5KHJhdGVzKSksXG4gICAgICAgIGRhdGFiYXNlLnNldGV4KCd0aHJlc2hvbGRzOmFsbCcsIDM2MDAsIEpTT04uc3RyaW5naWZ5KHRocmVzaG9sZHMpKSxcbiAgICAgICAgZGF0YWJhc2Uuc2V0ZXgoJ3JhdGVfZW5naW5lOmNvbmZpZycsIDM2MDAsIEpTT04uc3RyaW5naWZ5KHRoaXMuY29uZmlnKSksXG4gICAgICBdKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1JhdGVFbmdpbmVdIEVycm9yIHNhdmluZyBjb25maWd1cmF0aW9uOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFsbCByYXRlcyBmcm9tIG1hcmtldCBkYXRhXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHVwZGF0ZVJhdGVzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1tSYXRlRW5naW5lXSBVcGRhdGluZyByYXRlcy4uLicpO1xuXG4gICAgICAvLyBHZXQgbWFya2V0IGRhdGEgZm9yIGFsbCB0cmFja2VkIGN1cnJlbmN5IHBhaXJzXG4gICAgICBjb25zdCBjdXJyZW5jeVBhaXJzID0gdGhpcy5nZXRDdXJyZW5jeVBhaXJzKCk7XG5cbiAgICAgIGZvciAoY29uc3QgcGFpciBvZiBjdXJyZW5jeVBhaXJzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlUmF0ZUZvclBhaXIocGFpcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFNhdmUgdXBkYXRlZCByYXRlc1xuICAgICAgYXdhaXQgdGhpcy5zYXZlQ29uZmlndXJhdGlvbigpO1xuXG4gICAgICAvLyBDaGVjayB0aHJlc2hvbGRzIGFuZCBnZW5lcmF0ZSBhbGVydHNcbiAgICAgIHRoaXMuY2hlY2tUaHJlc2hvbGRzKCk7XG5cbiAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG5cbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5sYXN0VXBkYXRlIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5sb2coYFtSYXRlRW5naW5lXSBVcGRhdGVkICR7Y3VycmVuY3lQYWlycy5sZW5ndGh9IHJhdGVzIGluICR7ZHVyYXRpb259bXNgKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbUmF0ZUVuZ2luZV0gRXJyb3IgdXBkYXRpbmcgcmF0ZXM6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgcmF0ZSBmb3IgYSBzcGVjaWZpYyBjdXJyZW5jeSBwYWlyXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHVwZGF0ZVJhdGVGb3JQYWlyKHBhaXI6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBbYmFzZSwgdGFyZ2V0XSA9IHBhaXIuc3BsaXQoJy8nKTtcblxuICAgICAgLy8gR2V0IG1hcmtldCBkYXRhIGZvciB0aGlzIHBhaXJcbiAgICAgIGNvbnN0IG1hcmtldERhdGEgPSBhd2FpdCB0aGlzLmdldE1hcmtldERhdGEoYmFzZSwgdGFyZ2V0KTtcblxuICAgICAgaWYgKCFtYXJrZXREYXRhKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1JhdGVFbmdpbmVdIE5vIG1hcmtldCBkYXRhIGZvciAke3BhaXJ9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIHJhdGUgd2l0aCBzcHJlYWRcbiAgICAgIGNvbnN0IHJhdGUgPSB0aGlzLmNhbGN1bGF0ZVJhdGVXaXRoU3ByZWFkKG1hcmtldERhdGEsIHBhaXIpO1xuXG4gICAgICAvLyBVcGRhdGUgcmF0ZSBpbiBtZW1vcnlcbiAgICAgIHRoaXMucmF0ZXMuc2V0KHBhaXIucmVwbGFjZSgnLycsICcnKSwgcmF0ZSk7XG5cbiAgICAgIC8vIENhY2hlIGluZGl2aWR1YWwgcmF0ZVxuICAgICAgYXdhaXQgZGF0YWJhc2Uuc2V0ZXgoYHJhdGU6JHtwYWlyLnJlcGxhY2UoJy8nLCAnJyl9YCwgNjAsIEpTT04uc3RyaW5naWZ5KHJhdGUpKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbUmF0ZUVuZ2luZV0gRXJyb3IgdXBkYXRpbmcgcmF0ZSBmb3IgJHtwYWlyfTpgLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBtYXJrZXQgZGF0YSBmb3IgY3VycmVuY3kgcGFpclxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRNYXJrZXREYXRhKGJhc2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpOiBQcm9taXNlPE1hcmtldFJhdGVEYXRhIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgZGlmZmVyZW50IHNvdXJjZXNcbiAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHRoaXMuc291cmNlcykge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaEZyb21Tb3VyY2Uoc291cmNlLCBiYXNlLCB0YXJnZXQpO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbUmF0ZUVuZ2luZV0gRXJyb3IgZ2V0dGluZyBtYXJrZXQgZGF0YSBmb3IgJHtiYXNlfS8ke3RhcmdldH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGRhdGEgZnJvbSBzcGVjaWZpYyBzb3VyY2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hGcm9tU291cmNlKHNvdXJjZTogc3RyaW5nLCBiYXNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nKTogUHJvbWlzZTxNYXJrZXRSYXRlRGF0YSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgICAgY2FzZSAnY29pbmJhc2UnOlxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoQ29pbmJhc2VEYXRhKGJhc2UsIHRhcmdldCk7XG4gICAgICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoUG9seWdvbkRhdGEoYmFzZSwgdGFyZ2V0KTtcbiAgICAgICAgY2FzZSAndHdlbHZlZGF0YSc6XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hUd2VsdmVEYXRhRGF0YShiYXNlLCB0YXJnZXQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbUmF0ZUVuZ2luZV0gRXJyb3IgZmV0Y2hpbmcgZnJvbSAke3NvdXJjZX06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIENvaW5iYXNlIGRhdGFcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hDb2luYmFzZURhdGEoYmFzZTogc3RyaW5nLCB0YXJnZXQ6IHN0cmluZyk6IFByb21pc2U8TWFya2V0UmF0ZURhdGEgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhaXIgPSBgJHtiYXNlfS0ke3RhcmdldH1gO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkuZXhjaGFuZ2UuY29pbmJhc2UuY29tL3Byb2R1Y3RzLyR7cGFpcn0vdGlja2VyYCk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN5bWJvbDogcGFpcixcbiAgICAgICAgcHJpY2U6IHBhcnNlRmxvYXQoZGF0YS5wcmljZSksXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYmlkOiBwYXJzZUZsb2F0KGRhdGEuYmlkKSxcbiAgICAgICAgYXNrOiBwYXJzZUZsb2F0KGRhdGEuYXNrKSxcbiAgICAgICAgdm9sdW1lOiBwYXJzZUZsb2F0KGRhdGEudm9sdW1lKSxcbiAgICAgICAgc291cmNlOiAnY29pbmJhc2UnLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIFBvbHlnb24gZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaFBvbHlnb25EYXRhKGJhc2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpOiBQcm9taXNlPE1hcmtldFJhdGVEYXRhIHwgbnVsbD4ge1xuICAgIC8vIEltcGxlbWVudGF0aW9uIGZvciBQb2x5Z29uIEFQSVxuICAgIC8vIFRoaXMgd291bGQgcmVxdWlyZSBBUEkga2V5IGZyb20gZW52aXJvbm1lbnRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBUd2VsdmVEYXRhIGRhdGFcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hUd2VsdmVEYXRhRGF0YShiYXNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nKTogUHJvbWlzZTxNYXJrZXRSYXRlRGF0YSB8IG51bGw+IHtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBmb3IgVHdlbHZlRGF0YSBBUElcbiAgICAvLyBUaGlzIHdvdWxkIHJlcXVpcmUgQVBJIGtleSBmcm9tIGVudmlyb25tZW50XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHJhdGUgd2l0aCBzcHJlYWRcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlUmF0ZVdpdGhTcHJlYWQobWFya2V0RGF0YTogTWFya2V0UmF0ZURhdGEsIHBhaXI6IHN0cmluZyk6IEV4Y2hhbmdlUmF0ZSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGRzLmdldChwYWlyKTtcbiAgICBjb25zdCBiYXNlU3ByZWFkID0gdGhyZXNob2xkID8gKHRocmVzaG9sZC5taW5TcHJlYWQgKyB0aHJlc2hvbGQubWF4U3ByZWFkKSAvIDIgOiB0aGlzLmNvbmZpZy5kZWZhdWx0U3ByZWFkO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHZvbGF0aWxpdHktYWRqdXN0ZWQgc3ByZWFkXG4gICAgY29uc3Qgdm9sYXRpbGl0eVNwcmVhZCA9IHRoaXMuY2FsY3VsYXRlVm9sYXRpbGl0eVNwcmVhZChtYXJrZXREYXRhKTtcbiAgICBjb25zdCBmaW5hbFNwcmVhZCA9IE1hdGgubWF4KFxuICAgICAgTWF0aC5taW4oYmFzZVNwcmVhZCArIHZvbGF0aWxpdHlTcHJlYWQsIHRoaXMuY29uZmlnLm1heFNwcmVhZCksXG4gICAgICB0aGlzLmNvbmZpZy5taW5TcHJlYWRcbiAgICApO1xuXG4gICAgY29uc3QgYnV5UmF0ZSA9IG1hcmtldERhdGEucHJpY2UgKiAoMSArIGZpbmFsU3ByZWFkIC8gMik7XG4gICAgY29uc3Qgc2VsbFJhdGUgPSBtYXJrZXREYXRhLnByaWNlICogKDEgLSBmaW5hbFNwcmVhZCAvIDIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBgJHtwYWlyfV8ke0RhdGUubm93KCl9YCxcbiAgICAgIGJhc2VDdXJyZW5jeTogcGFpci5zcGxpdCgnLycpWzBdIHx8IHBhaXIuc2xpY2UoMCwgMyksXG4gICAgICB0YXJnZXRDdXJyZW5jeTogcGFpci5zcGxpdCgnLycpWzFdIHx8IHBhaXIuc2xpY2UoMyksXG4gICAgICByYXRlOiBtYXJrZXREYXRhLnByaWNlLFxuICAgICAgc3ByZWFkOiBmaW5hbFNwcmVhZCxcbiAgICAgIGJ1eVJhdGUsXG4gICAgICBzZWxsUmF0ZSxcbiAgICAgIHRpbWVzdGFtcDogbWFya2V0RGF0YS50aW1lc3RhbXAsXG4gICAgICBzb3VyY2U6ICdjYWxjdWxhdGVkJyxcbiAgICAgIGlzQWN0aXZlOiB0cnVlLFxuICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdm9sYXRpbGl0eS1iYXNlZCBzcHJlYWQgYWRqdXN0bWVudFxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVWb2xhdGlsaXR5U3ByZWFkKG1hcmtldERhdGE6IE1hcmtldFJhdGVEYXRhKTogbnVtYmVyIHtcbiAgICBpZiAoIW1hcmtldERhdGEuY2hhbmdlUGVyY2VudDI0aCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3Qgdm9sYXRpbGl0eSA9IE1hdGguYWJzKG1hcmtldERhdGEuY2hhbmdlUGVyY2VudDI0aCAvIDEwMCk7XG4gICAgcmV0dXJuIHZvbGF0aWxpdHkgKiB0aGlzLmNvbmZpZy52b2xhdGlsaXR5RmFjdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRocmVzaG9sZHMgYW5kIGdlbmVyYXRlIGFsZXJ0c1xuICAgKi9cbiAgcHJpdmF0ZSBjaGVja1RocmVzaG9sZHMoKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBbcGFpciwgdGhyZXNob2xkXSBvZiB0aGlzLnRocmVzaG9sZHMpIHtcbiAgICAgIGNvbnN0IHJhdGUgPSB0aGlzLnJhdGVzLmdldChwYWlyLnJlcGxhY2UoJy8nLCAnJykpO1xuXG4gICAgICBpZiAoIXJhdGUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBDaGVjayBzcHJlYWQgdGhyZXNob2xkc1xuICAgICAgaWYgKHJhdGUuc3ByZWFkIDwgdGhyZXNob2xkLm1pblNwcmVhZCB8fCByYXRlLnNwcmVhZCA+IHRocmVzaG9sZC5tYXhTcHJlYWQpIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUFsZXJ0KHtcbiAgICAgICAgICBpZDogYGFsZXJ0XyR7RGF0ZS5ub3coKX1fJHtwYWlyfWAsXG4gICAgICAgICAgY3VycmVuY3lQYWlyOiBwYWlyLFxuICAgICAgICAgIGFsZXJ0VHlwZTogJ3RocmVzaG9sZF9icmVhY2gnLFxuICAgICAgICAgIG1lc3NhZ2U6IGBTcHJlYWQgJHsocmF0ZS5zcHJlYWQgKiAxMDApLnRvRml4ZWQoMil9JSBvdXRzaWRlIHRocmVzaG9sZCByYW5nZSAkeyh0aHJlc2hvbGQubWluU3ByZWFkICogMTAwKS50b0ZpeGVkKDIpfSUtJHsodGhyZXNob2xkLm1heFNwcmVhZCAqIDEwMCkudG9GaXhlZCgyKX0lYCxcbiAgICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIGFja25vd2xlZGdlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayByYXRlIGZyZXNobmVzc1xuICAgICAgY29uc3QgYWdlTWludXRlcyA9IChEYXRlLm5vdygpIC0gcmF0ZS5sYXN0VXBkYXRlZCkgLyAoMTAwMCAqIDYwKTtcbiAgICAgIGlmIChhZ2VNaW51dGVzID4gNSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQWxlcnQoe1xuICAgICAgICAgIGlkOiBgYWxlcnRfJHtEYXRlLm5vdygpfV9zdGFsZV8ke3BhaXJ9YCxcbiAgICAgICAgICBjdXJyZW5jeVBhaXI6IHBhaXIsXG4gICAgICAgICAgYWxlcnRUeXBlOiAncmF0ZV9zdGFsZScsXG4gICAgICAgICAgbWVzc2FnZTogYFJhdGUgZm9yICR7cGFpcn0gaXMgJHthZ2VNaW51dGVzLnRvRml4ZWQoMSl9IG1pbnV0ZXMgb2xkYCxcbiAgICAgICAgICBzZXZlcml0eTogYWdlTWludXRlcyA+IDE1ID8gJ2hpZ2gnIDogJ21lZGl1bScsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIGFja25vd2xlZGdlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbGVydFxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZUFsZXJ0KGFsZXJ0OiBSYXRlQWxlcnQpOiB2b2lkIHtcbiAgICB0aGlzLmFsZXJ0cy5wdXNoKGFsZXJ0KTtcbiAgICBjb25zb2xlLndhcm4oYFtSYXRlRW5naW5lXSBBbGVydDogJHthbGVydC5tZXNzYWdlfWApO1xuXG4gICAgLy8gS2VlcCBvbmx5IGxhc3QgMTAwIGFsZXJ0c1xuICAgIGlmICh0aGlzLmFsZXJ0cy5sZW5ndGggPiAxMDApIHtcbiAgICAgIHRoaXMuYWxlcnRzID0gdGhpcy5hbGVydHMuc2xpY2UoLTEwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgY3VycmVuY3kgcGFpcnMgYmVpbmcgdHJhY2tlZFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRDdXJyZW5jeVBhaXJzKCk6IHN0cmluZ1tdIHtcbiAgICAvLyBEZWZhdWx0IHBhaXJzIC0gdGhpcyBjb3VsZCBiZSBjb25maWd1cmFibGVcbiAgICByZXR1cm4gW1xuICAgICAgJ1VTRC9DQUQnLFxuICAgICAgJ0VVUi9VU0QnLFxuICAgICAgJ0dCUC9VU0QnLFxuICAgICAgJ1VTRC9KUFknLFxuICAgICAgJ0FVRC9VU0QnLFxuICAgICAgJ1VTRC9DSEYnLFxuICAgICAgJ0JUQy9VU0QnLFxuICAgICAgJ0VUSC9VU0QnLFxuICAgICAgJ0JUQy9DQUQnLFxuICAgICAgJ0VUSC9DQUQnLFxuICAgIF07XG4gIH1cblxuICAvLyBQdWJsaWMgQVBJIG1ldGhvZHNcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgcmF0ZSBmb3IgY3VycmVuY3kgcGFpclxuICAgKi9cbiAgZ2V0UmF0ZShjdXJyZW5jeVBhaXI6IHN0cmluZyk6IEV4Y2hhbmdlUmF0ZSB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnJhdGVzLmdldChjdXJyZW5jeVBhaXIucmVwbGFjZSgnLycsICcnKSkgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGN1cnJlbnQgcmF0ZXNcbiAgICovXG4gIGdldEFsbFJhdGVzKCk6IEV4Y2hhbmdlUmF0ZVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJhdGVzLnZhbHVlcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgcmF0ZSBtYW51YWxseSAoZm9yIHN0b3JlIG93bmVycylcbiAgICovXG4gIGFzeW5jIHVwZGF0ZVJhdGVNYW51YWxseShyZXF1ZXN0OiBSYXRlVXBkYXRlUmVxdWVzdCk6IFByb21pc2U8RXhjaGFuZ2VSYXRlPiB7XG4gICAgY29uc3QgcGFpciA9IHJlcXVlc3QuY3VycmVuY3lQYWlyLnJlcGxhY2UoJy8nLCAnJyk7XG4gICAgY29uc3QgZXhpc3RpbmdSYXRlID0gdGhpcy5yYXRlcy5nZXQocGFpcik7XG5cbiAgICBpZiAoIWV4aXN0aW5nUmF0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSYXRlIG5vdCBmb3VuZCBmb3IgJHtyZXF1ZXN0LmN1cnJlbmN5UGFpcn1gKTtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVkUmF0ZTogRXhjaGFuZ2VSYXRlID0ge1xuICAgICAgLi4uZXhpc3RpbmdSYXRlLFxuICAgICAgc3ByZWFkOiByZXF1ZXN0LnNwcmVhZCB8fCBleGlzdGluZ1JhdGUuc3ByZWFkLFxuICAgICAgYnV5UmF0ZTogcmVxdWVzdC5idXlSYXRlIHx8IGV4aXN0aW5nUmF0ZS5idXlSYXRlLFxuICAgICAgc2VsbFJhdGU6IHJlcXVlc3Quc2VsbFJhdGUgfHwgZXhpc3RpbmdSYXRlLnNlbGxSYXRlLFxuICAgICAgc291cmNlOiByZXF1ZXN0LnNvdXJjZSxcbiAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpLFxuICAgICAgc3RvcmVJZDogcmVxdWVzdC5zdG9yZUlkLFxuICAgIH07XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgbWFudWFsIHJhdGVcbiAgICBpZiAodXBkYXRlZFJhdGUuc3ByZWFkIDwgdGhpcy5jb25maWcubWluU3ByZWFkIHx8IHVwZGF0ZWRSYXRlLnNwcmVhZCA+IHRoaXMuY29uZmlnLm1heFNwcmVhZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTcHJlYWQgJHsodXBkYXRlZFJhdGUuc3ByZWFkICogMTAwKS50b0ZpeGVkKDIpfSUgb3V0c2lkZSBhbGxvd2VkIHJhbmdlICR7KHRoaXMuY29uZmlnLm1pblNwcmVhZCAqIDEwMCkudG9GaXhlZCgyKX0lLSR7KHRoaXMuY29uZmlnLm1heFNwcmVhZCAqIDEwMCkudG9GaXhlZCgyKX0lYCk7XG4gICAgfVxuXG4gICAgdGhpcy5yYXRlcy5zZXQocGFpciwgdXBkYXRlZFJhdGUpO1xuXG4gICAgLy8gU2F2ZSB0byBkYXRhYmFzZVxuICAgIGF3YWl0IGRhdGFiYXNlLnNldGV4KGByYXRlOiR7cGFpcn1gLCAzNjAwLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkUmF0ZSkpO1xuXG4gICAgcmV0dXJuIHVwZGF0ZWRSYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCByYXRlIHRocmVzaG9sZFxuICAgKi9cbiAgYXN5bmMgYWRkVGhyZXNob2xkKHRocmVzaG9sZDogUmF0ZVRocmVzaG9sZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMudGhyZXNob2xkcy5zZXQodGhyZXNob2xkLmN1cnJlbmN5UGFpciwgdGhyZXNob2xkKTtcbiAgICBhd2FpdCB0aGlzLnNhdmVDb25maWd1cmF0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGVuZ2luZSBzdGF0dXNcbiAgICovXG4gIGdldFN0YXR1cygpOiBSYXRlRW5naW5lU3RhdHVzIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNSdW5uaW5nOiB0aGlzLmlzUnVubmluZyxcbiAgICAgIGxhc3RVcGRhdGU6IHRoaXMubGFzdFVwZGF0ZSxcbiAgICAgIGFjdGl2ZVNvdXJjZXM6IEFycmF5LmZyb20odGhpcy5zb3VyY2VzKSxcbiAgICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnM6IHRoaXMuc3Vic2NyaWJlcnMuc2l6ZSxcbiAgICAgIHJhdGVDb3VudDogdGhpcy5yYXRlcy5zaXplLFxuICAgICAgYWxlcnRDb3VudDogdGhpcy5hbGVydHMubGVuZ3RoLFxuICAgICAgbG9ja0NvdW50OiAwLCAvLyBUT0RPOiBJbXBsZW1lbnQgcmF0ZSBsb2Nrc1xuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgYXZnVXBkYXRlVGltZTogMCwgLy8gVE9ETzogVHJhY2sgcGVyZm9ybWFuY2UgbWV0cmljc1xuICAgICAgICBtYXhVcGRhdGVUaW1lOiAwLFxuICAgICAgICBlcnJvclJhdGU6IDAsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHJhdGUgdXBkYXRlc1xuICAgKi9cbiAgc3Vic2NyaWJlKGNsaWVudElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChjbGllbnRJZCk7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSByYXRlIHVwZGF0ZXNcbiAgICovXG4gIHVuc3Vic2NyaWJlKGNsaWVudElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjbGllbnRJZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlY2VudCBhbGVydHNcbiAgICovXG4gIGdldEFsZXJ0cyhsaW1pdDogbnVtYmVyID0gNTApOiBSYXRlQWxlcnRbXSB7XG4gICAgcmV0dXJuIHRoaXMuYWxlcnRzLnNsaWNlKC1saW1pdCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJhdGVFbmdpbmUgPSBSYXRlRW5naW5lLmdldEluc3RhbmNlKCk7XG5leHBvcnQgZGVmYXVsdCByYXRlRW5naW5lOyJdLCJuYW1lcyI6WyJkYXRhYmFzZSIsIlJhdGVFbmdpbmUiLCJjb25zdHJ1Y3RvciIsImlzUnVubmluZyIsInJhdGVzIiwiTWFwIiwidGhyZXNob2xkcyIsImFsZXJ0cyIsImxhc3RVcGRhdGUiLCJzb3VyY2VzIiwiU2V0Iiwic3Vic2NyaWJlcnMiLCJjb25maWciLCJkZWZhdWx0U3ByZWFkIiwibWluU3ByZWFkIiwibWF4U3ByZWFkIiwidm9sYXRpbGl0eUZhY3RvciIsImxpcXVpZGl0eUZhY3RvciIsInVwZGF0ZUZyZXF1ZW5jeSIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJzdGFydCIsImNvbnNvbGUiLCJsb2ciLCJsb2FkQ29uZmlndXJhdGlvbiIsInVwZGF0ZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ1cGRhdGVSYXRlcyIsImNhdGNoIiwiZXJyb3IiLCJzdG9wIiwiY2xlYXJJbnRlcnZhbCIsInVuZGVmaW5lZCIsInJhdGVzRGF0YSIsImdldCIsIkpTT04iLCJwYXJzZSIsImZvckVhY2giLCJyYXRlIiwic2V0IiwiYmFzZUN1cnJlbmN5IiwidGFyZ2V0Q3VycmVuY3kiLCJ0aHJlc2hvbGRzRGF0YSIsInRocmVzaG9sZCIsImN1cnJlbmN5UGFpciIsImNvbmZpZ0RhdGEiLCJzYXZlQ29uZmlndXJhdGlvbiIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsIlByb21pc2UiLCJhbGwiLCJzZXRleCIsInN0cmluZ2lmeSIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJjdXJyZW5jeVBhaXJzIiwiZ2V0Q3VycmVuY3lQYWlycyIsInBhaXIiLCJ1cGRhdGVSYXRlRm9yUGFpciIsImNoZWNrVGhyZXNob2xkcyIsImR1cmF0aW9uIiwibGVuZ3RoIiwiYmFzZSIsInRhcmdldCIsInNwbGl0IiwibWFya2V0RGF0YSIsImdldE1hcmtldERhdGEiLCJ3YXJuIiwiY2FsY3VsYXRlUmF0ZVdpdGhTcHJlYWQiLCJyZXBsYWNlIiwic291cmNlIiwiZGF0YSIsImZldGNoRnJvbVNvdXJjZSIsImZldGNoQ29pbmJhc2VEYXRhIiwiZmV0Y2hQb2x5Z29uRGF0YSIsImZldGNoVHdlbHZlRGF0YURhdGEiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJqc29uIiwic3ltYm9sIiwicHJpY2UiLCJwYXJzZUZsb2F0IiwidGltZXN0YW1wIiwiYmlkIiwiYXNrIiwidm9sdW1lIiwiYmFzZVNwcmVhZCIsInZvbGF0aWxpdHlTcHJlYWQiLCJjYWxjdWxhdGVWb2xhdGlsaXR5U3ByZWFkIiwiZmluYWxTcHJlYWQiLCJNYXRoIiwibWF4IiwibWluIiwiYnV5UmF0ZSIsInNlbGxSYXRlIiwiaWQiLCJzbGljZSIsInNwcmVhZCIsImlzQWN0aXZlIiwibGFzdFVwZGF0ZWQiLCJjaGFuZ2VQZXJjZW50MjRoIiwidm9sYXRpbGl0eSIsImFicyIsImdlbmVyYXRlQWxlcnQiLCJhbGVydFR5cGUiLCJtZXNzYWdlIiwidG9GaXhlZCIsInNldmVyaXR5IiwiYWNrbm93bGVkZ2VkIiwiYWdlTWludXRlcyIsImFsZXJ0IiwicHVzaCIsImdldFJhdGUiLCJnZXRBbGxSYXRlcyIsInVwZGF0ZVJhdGVNYW51YWxseSIsInJlcXVlc3QiLCJleGlzdGluZ1JhdGUiLCJFcnJvciIsInVwZGF0ZWRSYXRlIiwic3RvcmVJZCIsImFkZFRocmVzaG9sZCIsImdldFN0YXR1cyIsImFjdGl2ZVNvdXJjZXMiLCJhY3RpdmVTdWJzY3JpcHRpb25zIiwic2l6ZSIsInJhdGVDb3VudCIsImFsZXJ0Q291bnQiLCJsb2NrQ291bnQiLCJwZXJmb3JtYW5jZSIsImF2Z1VwZGF0ZVRpbWUiLCJtYXhVcGRhdGVUaW1lIiwiZXJyb3JSYXRlIiwic3Vic2NyaWJlIiwiY2xpZW50SWQiLCJhZGQiLCJ1bnN1YnNjcmliZSIsImRlbGV0ZSIsImdldEFsZXJ0cyIsImxpbWl0IiwicmF0ZUVuZ2luZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./lib/rate-engine.ts\n");

/***/ }),

/***/ "(api)/./lib/rate-limiter.ts":
/*!*****************************!*\
  !*** ./lib/rate-limiter.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RateLimitService: () => (/* binding */ RateLimitService),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   rateLimiter: () => (/* binding */ rateLimiter)\n/* harmony export */ });\n/* harmony import */ var rate_limiter_flexible__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rate-limiter-flexible */ \"rate-limiter-flexible\");\n/* harmony import */ var rate_limiter_flexible__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rate_limiter_flexible__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _security__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./security */ \"(api)/./lib/security.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_security__WEBPACK_IMPORTED_MODULE_1__]);\n_security__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * Rate Limiting Service for LeaperFX Backend API\n */ \n\nclass RateLimitService {\n    constructor(){\n        this.limiters = new Map();\n        this.isRedisAvailable = !!(process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN);\n        this.initializeDefaultLimiters();\n    }\n    static getInstance() {\n        if (!RateLimitService.instance) {\n            RateLimitService.instance = new RateLimitService();\n        }\n        return RateLimitService.instance;\n    }\n    initializeDefaultLimiters() {\n        // API endpoints rate limiting\n        this.createLimiter(\"api\", {\n            windowMs: 60000,\n            maxRequests: parseInt(process.env.RATE_LIMIT_REQUESTS || \"1000\")\n        });\n        // Data endpoints (more restrictive)\n        this.createLimiter(\"data\", {\n            windowMs: 60000,\n            maxRequests: 500\n        });\n        // Configuration endpoints (very restrictive)\n        this.createLimiter(\"config\", {\n            windowMs: 60000,\n            maxRequests: 100\n        });\n        // Health check (generous)\n        this.createLimiter(\"health\", {\n            windowMs: 60000,\n            maxRequests: 60\n        });\n        // Authentication (strict)\n        this.createLimiter(\"auth\", {\n            windowMs: 300000,\n            maxRequests: 20\n        });\n        // WebSocket connections\n        this.createLimiter(\"ws\", {\n            windowMs: 300000,\n            maxRequests: 10\n        });\n        // Rate management endpoints (moderate limits for store operations)\n        this.createLimiter(\"rates\", {\n            windowMs: 60000,\n            maxRequests: 200\n        });\n        // Market data endpoints (generous for real-time needs)\n        this.createLimiter(\"market_data\", {\n            windowMs: 60000,\n            maxRequests: 1000\n        });\n    }\n    createLimiter(name, config) {\n        const options = {\n            keyPrefix: `rl_${name}`,\n            points: config.maxRequests,\n            duration: Math.floor(config.windowMs / 1000),\n            blockDuration: Math.floor(config.windowMs / 1000),\n            skipSuccessfulRequests: config.skipSuccessfulRequests || false,\n            skipFailedRequests: config.skipFailedRequests || false\n        };\n        let limiter;\n        if (this.isRedisAvailable) {\n            try {\n                limiter = new rate_limiter_flexible__WEBPACK_IMPORTED_MODULE_0__.RateLimiterRedis({\n                    ...options,\n                    storeClient: this.getRedisClient()\n                });\n            } catch (error) {\n                console.warn(`[RateLimit] Redis unavailable for ${name}, falling back to memory:`, error);\n                limiter = new rate_limiter_flexible__WEBPACK_IMPORTED_MODULE_0__.RateLimiterMemory(options);\n            }\n        } else {\n            limiter = new rate_limiter_flexible__WEBPACK_IMPORTED_MODULE_0__.RateLimiterMemory(options);\n        }\n        this.limiters.set(name, limiter);\n    }\n    getRedisClient() {\n        // For Vercel KV or Upstash Redis\n        const Redis = __webpack_require__(/*! ioredis */ \"ioredis\");\n        if (process.env.KV_URL) {\n            return new Redis(process.env.KV_URL);\n        }\n        if (process.env.UPSTASH_REDIS_REST_URL) {\n            return new Redis({\n                host: new URL(process.env.UPSTASH_REDIS_REST_URL).hostname,\n                port: parseInt(new URL(process.env.UPSTASH_REDIS_REST_URL).port) || 6379,\n                password: process.env.UPSTASH_REDIS_REST_TOKEN,\n                tls: {}\n            });\n        }\n        throw new Error(\"No Redis configuration found\");\n    }\n    /**\n   * Check rate limit for a request\n   */ async checkRateLimit(req, category = \"api\") {\n        const limiter = this.limiters.get(category);\n        if (!limiter) {\n            throw new Error(`Rate limiter not found for category: ${category}`);\n        }\n        const key = _security__WEBPACK_IMPORTED_MODULE_1__.security.getRateLimitKey(req, category);\n        try {\n            const result = await limiter.consume(key);\n            return {\n                limit: limiter.points,\n                remaining: result.remainingPoints || 0,\n                reset: Date.now() + (result.msBeforeNext || 0)\n            };\n        } catch (rateLimiterResult) {\n            // Rate limit exceeded\n            return {\n                limit: limiter.points,\n                remaining: 0,\n                reset: Date.now() + (rateLimiterResult.msBeforeNext || 0),\n                retryAfter: Math.round((rateLimiterResult.msBeforeNext || 0) / 1000)\n            };\n        }\n    }\n    /**\n   * Apply rate limiting to API response\n   */ async applyRateLimit(req, res, category = \"api\") {\n        try {\n            const rateLimitInfo = await this.checkRateLimit(req, category);\n            // Set rate limit headers\n            res.setHeader(\"X-RateLimit-Limit\", rateLimitInfo.limit.toString());\n            res.setHeader(\"X-RateLimit-Remaining\", rateLimitInfo.remaining.toString());\n            res.setHeader(\"X-RateLimit-Reset\", rateLimitInfo.reset.toString());\n            if (rateLimitInfo.retryAfter) {\n                res.setHeader(\"Retry-After\", rateLimitInfo.retryAfter.toString());\n                res.status(429).json({\n                    success: false,\n                    error: \"Rate limit exceeded\",\n                    code: \"RATE_LIMIT_EXCEEDED\",\n                    retryAfter: rateLimitInfo.retryAfter,\n                    timestamp: Date.now(),\n                    requestId: _security__WEBPACK_IMPORTED_MODULE_1__.security.generateRequestId()\n                });\n                return false;\n            }\n            return true;\n        } catch (error) {\n            console.error(\"[RateLimit] Error applying rate limit:\", error);\n            // On error, allow the request to proceed\n            return true;\n        }\n    }\n    /**\n   * Get rate limit status without consuming\n   */ async getRateLimitStatus(req, category = \"api\") {\n        const limiter = this.limiters.get(category);\n        if (!limiter) {\n            throw new Error(`Rate limiter not found for category: ${category}`);\n        }\n        const key = _security__WEBPACK_IMPORTED_MODULE_1__.security.getRateLimitKey(req, category);\n        try {\n            const result = await limiter.get(key);\n            return {\n                limit: limiter.points,\n                remaining: result ? result.remainingPoints : limiter.points,\n                reset: Date.now() + (result ? result.msBeforeNext : 0)\n            };\n        } catch (error) {\n            console.error(\"[RateLimit] Error getting status:\", error);\n            return {\n                limit: limiter.points,\n                remaining: limiter.points,\n                reset: Date.now() + 60000\n            };\n        }\n    }\n    /**\n   * Reset rate limit for a key\n   */ async resetRateLimit(req, category = \"api\") {\n        const limiter = this.limiters.get(category);\n        if (!limiter) {\n            throw new Error(`Rate limiter not found for category: ${category}`);\n        }\n        const key = _security__WEBPACK_IMPORTED_MODULE_1__.security.getRateLimitKey(req, category);\n        await limiter.delete(key);\n    }\n    /**\n   * Create custom rate limiter\n   */ createCustomLimiter(name, config) {\n        this.createLimiter(name, config);\n    }\n    /**\n   * Get all active limiters\n   */ getLimiters() {\n        return Array.from(this.limiters.keys());\n    }\n    /**\n   * Middleware function for easy integration\n   */ middleware(category = \"api\") {\n        return async (req, res, next)=>{\n            const canProceed = await this.applyRateLimit(req, res, category);\n            if (canProceed && next) {\n                next();\n            }\n            return canProceed;\n        };\n    }\n    /**\n   * Rate limit based on IP address only (for public endpoints)\n   */ async checkIPRateLimit(req, config) {\n        const ip = _security__WEBPACK_IMPORTED_MODULE_1__.security.getClientIP(req);\n        const key = `ip_rl:${ip}`;\n        const limiter = new rate_limiter_flexible__WEBPACK_IMPORTED_MODULE_0__.RateLimiterMemory({\n            keyPrefix: \"ip_rate_limit\",\n            points: config.maxRequests,\n            duration: Math.floor(config.windowMs / 1000),\n            blockDuration: Math.floor(config.windowMs / 1000)\n        });\n        try {\n            const result = await limiter.consume(key);\n            return {\n                limit: config.maxRequests,\n                remaining: result.remainingPoints || 0,\n                reset: Date.now() + (result.msBeforeNext || 0)\n            };\n        } catch (rateLimiterResult) {\n            return {\n                limit: config.maxRequests,\n                remaining: 0,\n                reset: Date.now() + (rateLimiterResult.msBeforeNext || 0),\n                retryAfter: Math.round((rateLimiterResult.msBeforeNext || 0) / 1000)\n            };\n        }\n    }\n}\nconst rateLimiter = RateLimitService.getInstance();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rateLimiter);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OEIsY0FBY3pGLGlCQUFpQlUsV0FBVyxHQUFHO0FBQzFELGlFQUFlK0UsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BsZWFwZXJmeC9hcGkvLi9saWIvcmF0ZS1saW1pdGVyLnRzP2I0MWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSYXRlIExpbWl0aW5nIFNlcnZpY2UgZm9yIExlYXBlckZYIEJhY2tlbmQgQVBJXG4gKi9cblxuaW1wb3J0IHsgUmF0ZUxpbWl0ZXJNZW1vcnksIFJhdGVMaW1pdGVyUmVkaXMgfSBmcm9tICdyYXRlLWxpbWl0ZXItZmxleGlibGUnO1xuaW1wb3J0IHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnO1xuaW1wb3J0IHsgUmF0ZUxpbWl0SW5mbywgUmF0ZUxpbWl0Q29uZmlnIH0gZnJvbSAnLi4vdHlwZXMvYXBpJztcbmltcG9ydCB7IHNlY3VyaXR5IH0gZnJvbSAnLi9zZWN1cml0eSc7XG5cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFJhdGVMaW1pdFNlcnZpY2U7XG4gIHByaXZhdGUgbGltaXRlcnM6IE1hcDxzdHJpbmcsIFJhdGVMaW1pdGVyTWVtb3J5IHwgUmF0ZUxpbWl0ZXJSZWRpcz47XG4gIHByaXZhdGUgaXNSZWRpc0F2YWlsYWJsZTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxpbWl0ZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaXNSZWRpc0F2YWlsYWJsZSA9ICEhKHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkwgJiYgcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOKTtcbiAgICB0aGlzLmluaXRpYWxpemVEZWZhdWx0TGltaXRlcnMoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBSYXRlTGltaXRTZXJ2aWNlIHtcbiAgICBpZiAoIVJhdGVMaW1pdFNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIFJhdGVMaW1pdFNlcnZpY2UuaW5zdGFuY2UgPSBuZXcgUmF0ZUxpbWl0U2VydmljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gUmF0ZUxpbWl0U2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZURlZmF1bHRMaW1pdGVycygpOiB2b2lkIHtcbiAgICAvLyBBUEkgZW5kcG9pbnRzIHJhdGUgbGltaXRpbmdcbiAgICB0aGlzLmNyZWF0ZUxpbWl0ZXIoJ2FwaScsIHtcbiAgICAgIHdpbmRvd01zOiA2MDAwMCwgLy8gMSBtaW51dGVcbiAgICAgIG1heFJlcXVlc3RzOiBwYXJzZUludChwcm9jZXNzLmVudi5SQVRFX0xJTUlUX1JFUVVFU1RTIHx8ICcxMDAwJyksXG4gICAgfSk7XG5cbiAgICAvLyBEYXRhIGVuZHBvaW50cyAobW9yZSByZXN0cmljdGl2ZSlcbiAgICB0aGlzLmNyZWF0ZUxpbWl0ZXIoJ2RhdGEnLCB7XG4gICAgICB3aW5kb3dNczogNjAwMDAsIC8vIDEgbWludXRlXG4gICAgICBtYXhSZXF1ZXN0czogNTAwLFxuICAgIH0pO1xuXG4gICAgLy8gQ29uZmlndXJhdGlvbiBlbmRwb2ludHMgKHZlcnkgcmVzdHJpY3RpdmUpXG4gICAgdGhpcy5jcmVhdGVMaW1pdGVyKCdjb25maWcnLCB7XG4gICAgICB3aW5kb3dNczogNjAwMDAsIC8vIDEgbWludXRlXG4gICAgICBtYXhSZXF1ZXN0czogMTAwLFxuICAgIH0pO1xuXG4gICAgLy8gSGVhbHRoIGNoZWNrIChnZW5lcm91cylcbiAgICB0aGlzLmNyZWF0ZUxpbWl0ZXIoJ2hlYWx0aCcsIHtcbiAgICAgIHdpbmRvd01zOiA2MDAwMCwgLy8gMSBtaW51dGVcbiAgICAgIG1heFJlcXVlc3RzOiA2MCxcbiAgICB9KTtcblxuICAgIC8vIEF1dGhlbnRpY2F0aW9uIChzdHJpY3QpXG4gICAgdGhpcy5jcmVhdGVMaW1pdGVyKCdhdXRoJywge1xuICAgICAgd2luZG93TXM6IDMwMDAwMCwgLy8gNSBtaW51dGVzXG4gICAgICBtYXhSZXF1ZXN0czogMjAsXG4gICAgfSk7XG5cbiAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbnNcbiAgICB0aGlzLmNyZWF0ZUxpbWl0ZXIoJ3dzJywge1xuICAgICAgd2luZG93TXM6IDMwMDAwMCwgLy8gNSBtaW51dGVzXG4gICAgICBtYXhSZXF1ZXN0czogMTAsXG4gICAgfSk7XG5cbiAgICAvLyBSYXRlIG1hbmFnZW1lbnQgZW5kcG9pbnRzIChtb2RlcmF0ZSBsaW1pdHMgZm9yIHN0b3JlIG9wZXJhdGlvbnMpXG4gICAgdGhpcy5jcmVhdGVMaW1pdGVyKCdyYXRlcycsIHtcbiAgICAgIHdpbmRvd01zOiA2MDAwMCwgLy8gMSBtaW51dGVcbiAgICAgIG1heFJlcXVlc3RzOiAyMDAsXG4gICAgfSk7XG5cbiAgICAvLyBNYXJrZXQgZGF0YSBlbmRwb2ludHMgKGdlbmVyb3VzIGZvciByZWFsLXRpbWUgbmVlZHMpXG4gICAgdGhpcy5jcmVhdGVMaW1pdGVyKCdtYXJrZXRfZGF0YScsIHtcbiAgICAgIHdpbmRvd01zOiA2MDAwMCwgLy8gMSBtaW51dGVcbiAgICAgIG1heFJlcXVlc3RzOiAxMDAwLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVMaW1pdGVyKG5hbWU6IHN0cmluZywgY29uZmlnOiBSYXRlTGltaXRDb25maWcpOiB2b2lkIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAga2V5UHJlZml4OiBgcmxfJHtuYW1lfWAsXG4gICAgICBwb2ludHM6IGNvbmZpZy5tYXhSZXF1ZXN0cyxcbiAgICAgIGR1cmF0aW9uOiBNYXRoLmZsb29yKGNvbmZpZy53aW5kb3dNcyAvIDEwMDApLFxuICAgICAgYmxvY2tEdXJhdGlvbjogTWF0aC5mbG9vcihjb25maWcud2luZG93TXMgLyAxMDAwKSxcbiAgICAgIHNraXBTdWNjZXNzZnVsUmVxdWVzdHM6IGNvbmZpZy5za2lwU3VjY2Vzc2Z1bFJlcXVlc3RzIHx8IGZhbHNlLFxuICAgICAgc2tpcEZhaWxlZFJlcXVlc3RzOiBjb25maWcuc2tpcEZhaWxlZFJlcXVlc3RzIHx8IGZhbHNlLFxuICAgIH07XG5cbiAgICBsZXQgbGltaXRlcjtcblxuICAgIGlmICh0aGlzLmlzUmVkaXNBdmFpbGFibGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpbWl0ZXIgPSBuZXcgUmF0ZUxpbWl0ZXJSZWRpcyh7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBzdG9yZUNsaWVudDogdGhpcy5nZXRSZWRpc0NsaWVudCgpLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1JhdGVMaW1pdF0gUmVkaXMgdW5hdmFpbGFibGUgZm9yICR7bmFtZX0sIGZhbGxpbmcgYmFjayB0byBtZW1vcnk6YCwgZXJyb3IpO1xuICAgICAgICBsaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyTWVtb3J5KG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyTWVtb3J5KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMubGltaXRlcnMuc2V0KG5hbWUsIGxpbWl0ZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRSZWRpc0NsaWVudCgpOiBhbnkge1xuICAgIC8vIEZvciBWZXJjZWwgS1Ygb3IgVXBzdGFzaCBSZWRpc1xuICAgIGNvbnN0IFJlZGlzID0gcmVxdWlyZSgnaW9yZWRpcycpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52LktWX1VSTCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWRpcyhwcm9jZXNzLmVudi5LVl9VUkwpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZGlzKHtcbiAgICAgICAgaG9zdDogbmV3IFVSTChwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMKS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogcGFyc2VJbnQobmV3IFVSTChwcm9jZXNzLmVudi5VUFNUQVNIX1JFRElTX1JFU1RfVVJMKS5wb3J0KSB8fCA2Mzc5LFxuICAgICAgICBwYXNzd29yZDogcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOLFxuICAgICAgICB0bHM6IHt9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBSZWRpcyBjb25maWd1cmF0aW9uIGZvdW5kJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgcmF0ZSBsaW1pdCBmb3IgYSByZXF1ZXN0XG4gICAqL1xuICBhc3luYyBjaGVja1JhdGVMaW1pdChcbiAgICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICAgIGNhdGVnb3J5OiBzdHJpbmcgPSAnYXBpJ1xuICApOiBQcm9taXNlPFJhdGVMaW1pdEluZm8+IHtcbiAgICBjb25zdCBsaW1pdGVyID0gdGhpcy5saW1pdGVycy5nZXQoY2F0ZWdvcnkpO1xuXG4gICAgaWYgKCFsaW1pdGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJhdGUgbGltaXRlciBub3QgZm91bmQgZm9yIGNhdGVnb3J5OiAke2NhdGVnb3J5fWApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHNlY3VyaXR5LmdldFJhdGVMaW1pdEtleShyZXEsIGNhdGVnb3J5KTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaW1pdGVyLmNvbnN1bWUoa2V5KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGltaXQ6IGxpbWl0ZXIucG9pbnRzLFxuICAgICAgICByZW1haW5pbmc6IHJlc3VsdC5yZW1haW5pbmdQb2ludHMgfHwgMCxcbiAgICAgICAgcmVzZXQ6IERhdGUubm93KCkgKyAocmVzdWx0Lm1zQmVmb3JlTmV4dCB8fCAwKSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAocmF0ZUxpbWl0ZXJSZXN1bHQ6IGFueSkge1xuICAgICAgLy8gUmF0ZSBsaW1pdCBleGNlZWRlZFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGltaXQ6IGxpbWl0ZXIucG9pbnRzLFxuICAgICAgICByZW1haW5pbmc6IDAsXG4gICAgICAgIHJlc2V0OiBEYXRlLm5vdygpICsgKHJhdGVMaW1pdGVyUmVzdWx0Lm1zQmVmb3JlTmV4dCB8fCAwKSxcbiAgICAgICAgcmV0cnlBZnRlcjogTWF0aC5yb3VuZCgocmF0ZUxpbWl0ZXJSZXN1bHQubXNCZWZvcmVOZXh0IHx8IDApIC8gMTAwMCksXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSByYXRlIGxpbWl0aW5nIHRvIEFQSSByZXNwb25zZVxuICAgKi9cbiAgYXN5bmMgYXBwbHlSYXRlTGltaXQoXG4gICAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgICByZXM6IE5leHRBcGlSZXNwb25zZSxcbiAgICBjYXRlZ29yeTogc3RyaW5nID0gJ2FwaSdcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhdGVMaW1pdEluZm8gPSBhd2FpdCB0aGlzLmNoZWNrUmF0ZUxpbWl0KHJlcSwgY2F0ZWdvcnkpO1xuXG4gICAgICAvLyBTZXQgcmF0ZSBsaW1pdCBoZWFkZXJzXG4gICAgICByZXMuc2V0SGVhZGVyKCdYLVJhdGVMaW1pdC1MaW1pdCcsIHJhdGVMaW1pdEluZm8ubGltaXQudG9TdHJpbmcoKSk7XG4gICAgICByZXMuc2V0SGVhZGVyKCdYLVJhdGVMaW1pdC1SZW1haW5pbmcnLCByYXRlTGltaXRJbmZvLnJlbWFpbmluZy50b1N0cmluZygpKTtcbiAgICAgIHJlcy5zZXRIZWFkZXIoJ1gtUmF0ZUxpbWl0LVJlc2V0JywgcmF0ZUxpbWl0SW5mby5yZXNldC50b1N0cmluZygpKTtcblxuICAgICAgaWYgKHJhdGVMaW1pdEluZm8ucmV0cnlBZnRlcikge1xuICAgICAgICByZXMuc2V0SGVhZGVyKCdSZXRyeS1BZnRlcicsIHJhdGVMaW1pdEluZm8ucmV0cnlBZnRlci50b1N0cmluZygpKTtcbiAgICAgICAgcmVzLnN0YXR1cyg0MjkpLmpzb24oe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiAnUmF0ZSBsaW1pdCBleGNlZWRlZCcsXG4gICAgICAgICAgY29kZTogJ1JBVEVfTElNSVRfRVhDRUVERUQnLFxuICAgICAgICAgIHJldHJ5QWZ0ZXI6IHJhdGVMaW1pdEluZm8ucmV0cnlBZnRlcixcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgcmVxdWVzdElkOiBzZWN1cml0eS5nZW5lcmF0ZVJlcXVlc3RJZCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1JhdGVMaW1pdF0gRXJyb3IgYXBwbHlpbmcgcmF0ZSBsaW1pdDonLCBlcnJvcik7XG4gICAgICAvLyBPbiBlcnJvciwgYWxsb3cgdGhlIHJlcXVlc3QgdG8gcHJvY2VlZFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCByYXRlIGxpbWl0IHN0YXR1cyB3aXRob3V0IGNvbnN1bWluZ1xuICAgKi9cbiAgYXN5bmMgZ2V0UmF0ZUxpbWl0U3RhdHVzKHJlcTogTmV4dEFwaVJlcXVlc3QsIGNhdGVnb3J5OiBzdHJpbmcgPSAnYXBpJyk6IFByb21pc2U8UmF0ZUxpbWl0SW5mbz4ge1xuICAgIGNvbnN0IGxpbWl0ZXIgPSB0aGlzLmxpbWl0ZXJzLmdldChjYXRlZ29yeSk7XG5cbiAgICBpZiAoIWxpbWl0ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmF0ZSBsaW1pdGVyIG5vdCBmb3VuZCBmb3IgY2F0ZWdvcnk6ICR7Y2F0ZWdvcnl9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gc2VjdXJpdHkuZ2V0UmF0ZUxpbWl0S2V5KHJlcSwgY2F0ZWdvcnkpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxpbWl0ZXIuZ2V0KGtleSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbWl0OiBsaW1pdGVyLnBvaW50cyxcbiAgICAgICAgcmVtYWluaW5nOiByZXN1bHQgPyByZXN1bHQucmVtYWluaW5nUG9pbnRzIDogbGltaXRlci5wb2ludHMsXG4gICAgICAgIHJlc2V0OiBEYXRlLm5vdygpICsgKHJlc3VsdCA/IHJlc3VsdC5tc0JlZm9yZU5leHQgOiAwKSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tSYXRlTGltaXRdIEVycm9yIGdldHRpbmcgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbWl0OiBsaW1pdGVyLnBvaW50cyxcbiAgICAgICAgcmVtYWluaW5nOiBsaW1pdGVyLnBvaW50cyxcbiAgICAgICAgcmVzZXQ6IERhdGUubm93KCkgKyA2MDAwMCxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHJhdGUgbGltaXQgZm9yIGEga2V5XG4gICAqL1xuICBhc3luYyByZXNldFJhdGVMaW1pdChyZXE6IE5leHRBcGlSZXF1ZXN0LCBjYXRlZ29yeTogc3RyaW5nID0gJ2FwaScpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBsaW1pdGVyID0gdGhpcy5saW1pdGVycy5nZXQoY2F0ZWdvcnkpO1xuXG4gICAgaWYgKCFsaW1pdGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJhdGUgbGltaXRlciBub3QgZm91bmQgZm9yIGNhdGVnb3J5OiAke2NhdGVnb3J5fWApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHNlY3VyaXR5LmdldFJhdGVMaW1pdEtleShyZXEsIGNhdGVnb3J5KTtcbiAgICBhd2FpdCBsaW1pdGVyLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjdXN0b20gcmF0ZSBsaW1pdGVyXG4gICAqL1xuICBjcmVhdGVDdXN0b21MaW1pdGVyKG5hbWU6IHN0cmluZywgY29uZmlnOiBSYXRlTGltaXRDb25maWcpOiB2b2lkIHtcbiAgICB0aGlzLmNyZWF0ZUxpbWl0ZXIobmFtZSwgY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGFjdGl2ZSBsaW1pdGVyc1xuICAgKi9cbiAgZ2V0TGltaXRlcnMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubGltaXRlcnMua2V5cygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaWRkbGV3YXJlIGZ1bmN0aW9uIGZvciBlYXN5IGludGVncmF0aW9uXG4gICAqL1xuICBtaWRkbGV3YXJlKGNhdGVnb3J5OiBzdHJpbmcgPSAnYXBpJykge1xuICAgIHJldHVybiBhc3luYyAocmVxOiBOZXh0QXBpUmVxdWVzdCwgcmVzOiBOZXh0QXBpUmVzcG9uc2UsIG5leHQ/OiBGdW5jdGlvbikgPT4ge1xuICAgICAgY29uc3QgY2FuUHJvY2VlZCA9IGF3YWl0IHRoaXMuYXBwbHlSYXRlTGltaXQocmVxLCByZXMsIGNhdGVnb3J5KTtcblxuICAgICAgaWYgKGNhblByb2NlZWQgJiYgbmV4dCkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYW5Qcm9jZWVkO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmF0ZSBsaW1pdCBiYXNlZCBvbiBJUCBhZGRyZXNzIG9ubHkgKGZvciBwdWJsaWMgZW5kcG9pbnRzKVxuICAgKi9cbiAgYXN5bmMgY2hlY2tJUFJhdGVMaW1pdChcbiAgICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICAgIGNvbmZpZzogeyB3aW5kb3dNczogbnVtYmVyOyBtYXhSZXF1ZXN0czogbnVtYmVyIH1cbiAgKTogUHJvbWlzZTxSYXRlTGltaXRJbmZvPiB7XG4gICAgY29uc3QgaXAgPSBzZWN1cml0eS5nZXRDbGllbnRJUChyZXEpO1xuICAgIGNvbnN0IGtleSA9IGBpcF9ybDoke2lwfWA7XG5cbiAgICBjb25zdCBsaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyTWVtb3J5KHtcbiAgICAgIGtleVByZWZpeDogJ2lwX3JhdGVfbGltaXQnLFxuICAgICAgcG9pbnRzOiBjb25maWcubWF4UmVxdWVzdHMsXG4gICAgICBkdXJhdGlvbjogTWF0aC5mbG9vcihjb25maWcud2luZG93TXMgLyAxMDAwKSxcbiAgICAgIGJsb2NrRHVyYXRpb246IE1hdGguZmxvb3IoY29uZmlnLndpbmRvd01zIC8gMTAwMCksXG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGltaXRlci5jb25zdW1lKGtleSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbWl0OiBjb25maWcubWF4UmVxdWVzdHMsXG4gICAgICAgIHJlbWFpbmluZzogcmVzdWx0LnJlbWFpbmluZ1BvaW50cyB8fCAwLFxuICAgICAgICByZXNldDogRGF0ZS5ub3coKSArIChyZXN1bHQubXNCZWZvcmVOZXh0IHx8IDApLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChyYXRlTGltaXRlclJlc3VsdDogYW55KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW1pdDogY29uZmlnLm1heFJlcXVlc3RzLFxuICAgICAgICByZW1haW5pbmc6IDAsXG4gICAgICAgIHJlc2V0OiBEYXRlLm5vdygpICsgKHJhdGVMaW1pdGVyUmVzdWx0Lm1zQmVmb3JlTmV4dCB8fCAwKSxcbiAgICAgICAgcmV0cnlBZnRlcjogTWF0aC5yb3VuZCgocmF0ZUxpbWl0ZXJSZXN1bHQubXNCZWZvcmVOZXh0IHx8IDApIC8gMTAwMCksXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmF0ZUxpbWl0ZXIgPSBSYXRlTGltaXRTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG5leHBvcnQgZGVmYXVsdCByYXRlTGltaXRlcjsiXSwibmFtZXMiOlsiUmF0ZUxpbWl0ZXJNZW1vcnkiLCJSYXRlTGltaXRlclJlZGlzIiwic2VjdXJpdHkiLCJSYXRlTGltaXRTZXJ2aWNlIiwiY29uc3RydWN0b3IiLCJsaW1pdGVycyIsIk1hcCIsImlzUmVkaXNBdmFpbGFibGUiLCJwcm9jZXNzIiwiZW52IiwiVVBTVEFTSF9SRURJU19SRVNUX1VSTCIsIlVQU1RBU0hfUkVESVNfUkVTVF9UT0tFTiIsImluaXRpYWxpemVEZWZhdWx0TGltaXRlcnMiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiY3JlYXRlTGltaXRlciIsIndpbmRvd01zIiwibWF4UmVxdWVzdHMiLCJwYXJzZUludCIsIlJBVEVfTElNSVRfUkVRVUVTVFMiLCJuYW1lIiwiY29uZmlnIiwib3B0aW9ucyIsImtleVByZWZpeCIsInBvaW50cyIsImR1cmF0aW9uIiwiTWF0aCIsImZsb29yIiwiYmxvY2tEdXJhdGlvbiIsInNraXBTdWNjZXNzZnVsUmVxdWVzdHMiLCJza2lwRmFpbGVkUmVxdWVzdHMiLCJsaW1pdGVyIiwic3RvcmVDbGllbnQiLCJnZXRSZWRpc0NsaWVudCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJzZXQiLCJSZWRpcyIsInJlcXVpcmUiLCJLVl9VUkwiLCJob3N0IiwiVVJMIiwiaG9zdG5hbWUiLCJwb3J0IiwicGFzc3dvcmQiLCJ0bHMiLCJFcnJvciIsImNoZWNrUmF0ZUxpbWl0IiwicmVxIiwiY2F0ZWdvcnkiLCJnZXQiLCJrZXkiLCJnZXRSYXRlTGltaXRLZXkiLCJyZXN1bHQiLCJjb25zdW1lIiwibGltaXQiLCJyZW1haW5pbmciLCJyZW1haW5pbmdQb2ludHMiLCJyZXNldCIsIkRhdGUiLCJub3ciLCJtc0JlZm9yZU5leHQiLCJyYXRlTGltaXRlclJlc3VsdCIsInJldHJ5QWZ0ZXIiLCJyb3VuZCIsImFwcGx5UmF0ZUxpbWl0IiwicmVzIiwicmF0ZUxpbWl0SW5mbyIsInNldEhlYWRlciIsInRvU3RyaW5nIiwic3RhdHVzIiwianNvbiIsInN1Y2Nlc3MiLCJjb2RlIiwidGltZXN0YW1wIiwicmVxdWVzdElkIiwiZ2VuZXJhdGVSZXF1ZXN0SWQiLCJnZXRSYXRlTGltaXRTdGF0dXMiLCJyZXNldFJhdGVMaW1pdCIsImRlbGV0ZSIsImNyZWF0ZUN1c3RvbUxpbWl0ZXIiLCJnZXRMaW1pdGVycyIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJtaWRkbGV3YXJlIiwibmV4dCIsImNhblByb2NlZWQiLCJjaGVja0lQUmF0ZUxpbWl0IiwiaXAiLCJnZXRDbGllbnRJUCIsInJhdGVMaW1pdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/rate-limiter.ts\n");

/***/ }),

/***/ "(api)/./lib/security.ts":
/*!*************************!*\
  !*** ./lib/security.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SecurityService: () => (/* binding */ SecurityService),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   security: () => (/* binding */ security)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"uuid\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([uuid__WEBPACK_IMPORTED_MODULE_0__]);\nuuid__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * Security utilities for LeaperFX Backend API\n */ \nclass SecurityService {\n    constructor(){\n        this.secretKey = process.env.API_SECRET_KEY || \"fallback-dev-key-change-in-production\";\n    }\n    static getInstance() {\n        if (!SecurityService.instance) {\n            SecurityService.instance = new SecurityService();\n        }\n        return SecurityService.instance;\n    }\n    /**\n   * Generate a unique request ID\n   */ generateRequestId() {\n        return (0,uuid__WEBPACK_IMPORTED_MODULE_0__.v4)();\n    }\n    /**\n   * Extract client IP address from request\n   */ getClientIP(req) {\n        const forwarded = req.headers[\"x-forwarded-for\"];\n        const realIP = req.headers[\"x-real-ip\"];\n        const cfConnectingIP = req.headers[\"cf-connecting-ip\"];\n        if (typeof forwarded === \"string\") {\n            return forwarded.split(\",\")[0].trim();\n        }\n        if (typeof realIP === \"string\") {\n            return realIP;\n        }\n        if (typeof cfConnectingIP === \"string\") {\n            return cfConnectingIP;\n        }\n        return req.socket.remoteAddress || \"unknown\";\n    }\n    /**\n   * Create security context for request\n   */ createSecurityContext(req) {\n        return {\n            requestId: this.generateRequestId(),\n            clientId: req.headers[\"x-client-id\"],\n            ipAddress: this.getClientIP(req),\n            userAgent: req.headers[\"user-agent\"] || \"unknown\",\n            timestamp: Date.now(),\n            rateLimitInfo: {\n                limit: 1000,\n                remaining: 999,\n                reset: Date.now() + 60000\n            }\n        };\n    }\n    /**\n   * Validate API key from headers\n   */ validateApiKey(req) {\n        const apiKey = req.headers[\"x-api-key\"] || req.headers[\"authorization\"]?.replace(\"Bearer \", \"\");\n        // In development, allow requests without API key\n        if ( true && !apiKey) {\n            return true;\n        }\n        // For production, implement proper API key validation\n        if (!apiKey) {\n            return false;\n        }\n        // Simple validation - replace with proper JWT or API key system\n        return apiKey === this.secretKey || apiKey === process.env.API_SECRET_KEY;\n    }\n    /**\n   * Sanitize input to prevent XSS and injection attacks\n   */ sanitizeInput(input) {\n        if (typeof input === \"string\") {\n            return input.replace(/[<>]/g, \"\").replace(/javascript:/gi, \"\").replace(/on\\w+=/gi, \"\").trim();\n        }\n        if (Array.isArray(input)) {\n            return input.map((item)=>this.sanitizeInput(item));\n        }\n        if (typeof input === \"object\" && input !== null) {\n            const sanitized = {};\n            for (const [key, value] of Object.entries(input)){\n                sanitized[this.sanitizeInput(key)] = this.sanitizeInput(value);\n            }\n            return sanitized;\n        }\n        return input;\n    }\n    /**\n   * Validate request parameters\n   */ validateRequest(req, schema) {\n        const errors = [];\n        const data = {\n            ...req.query,\n            ...req.body\n        };\n        for (const [field, rules] of Object.entries(schema)){\n            const value = data[field];\n            const fieldRules = rules;\n            if (fieldRules.required && (value === undefined || value === null || value === \"\")) {\n                errors.push({\n                    field,\n                    message: `${field} is required`,\n                    value\n                });\n                continue;\n            }\n            if (value !== undefined && fieldRules.type) {\n                const actualType = Array.isArray(value) ? \"array\" : typeof value;\n                if (actualType !== fieldRules.type) {\n                    errors.push({\n                        field,\n                        message: `${field} must be of type ${fieldRules.type}`,\n                        value\n                    });\n                }\n            }\n            if (fieldRules.minLength && typeof value === \"string\" && value.length < fieldRules.minLength) {\n                errors.push({\n                    field,\n                    message: `${field} must be at least ${fieldRules.minLength} characters`,\n                    value\n                });\n            }\n            if (fieldRules.maxLength && typeof value === \"string\" && value.length > fieldRules.maxLength) {\n                errors.push({\n                    field,\n                    message: `${field} must be no more than ${fieldRules.maxLength} characters`,\n                    value\n                });\n            }\n            if (fieldRules.pattern && typeof value === \"string\" && !fieldRules.pattern.test(value)) {\n                errors.push({\n                    field,\n                    message: `${field} format is invalid`,\n                    value\n                });\n            }\n            if (fieldRules.enum && !fieldRules.enum.includes(value)) {\n                errors.push({\n                    field,\n                    message: `${field} must be one of: ${fieldRules.enum.join(\", \")}`,\n                    value\n                });\n            }\n        }\n        return errors;\n    }\n    /**\n   * Set security headers\n   */ setSecurityHeaders(res) {\n        res.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n        res.setHeader(\"X-Frame-Options\", \"DENY\");\n        res.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n        res.setHeader(\"Referrer-Policy\", \"strict-origin-when-cross-origin\");\n        res.setHeader(\"Content-Security-Policy\", \"default-src 'self'\");\n        if (false) {}\n    }\n    /**\n   * Check if request is from allowed origin\n   */ isOriginAllowed(origin) {\n        if (!origin) return true; // Allow same-origin requests\n        const allowedOrigins = [\n            \"http://localhost:3000\",\n            \"http://localhost:5173\",\n            \"https://leaperfx-dashboard.vercel.app\",\n            process.env.CORS_ORIGIN\n        ].filter(Boolean);\n        return allowedOrigins.includes(origin);\n    }\n    /**\n   * Generate CORS headers\n   */ getCorsHeaders(origin) {\n        const isAllowed = this.isOriginAllowed(origin);\n        return {\n            \"Access-Control-Allow-Origin\": isAllowed ? origin || \"*\" : \"null\",\n            \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n            \"Access-Control-Allow-Headers\": \"Content-Type, Authorization, X-API-Key, X-Request-ID, X-Client-ID\",\n            \"Access-Control-Max-Age\": \"86400\",\n            \"Vary\": \"Origin\"\n        };\n    }\n    /**\n   * Rate limiting key generation\n   */ getRateLimitKey(req, prefix = \"rl\") {\n        const ip = this.getClientIP(req);\n        const apiKey = req.headers[\"x-api-key\"] || \"anonymous\";\n        return `${prefix}:${ip}:${apiKey}`;\n    }\n    /**\n   * Check if request is suspicious\n   */ isSuspiciousRequest(req) {\n        const userAgent = req.headers[\"user-agent\"] || \"\";\n        const suspiciousPatterns = [\n            /bot/i,\n            /crawler/i,\n            /spider/i,\n            /scraper/i,\n            /curl/i,\n            /wget/i,\n            /python/i,\n            /postman/i\n        ];\n        // Allow legitimate crawlers and development tools\n        const allowedPatterns = [\n            /googlebot/i,\n            /bingbot/i,\n            /slackbot/i,\n            /facebookexternalhit/i,\n            /twitterbot/i,\n            /linkedinbot/i,\n            /chrome/i,\n            /firefox/i,\n            /safari/i,\n            /edge/i\n        ];\n        if (allowedPatterns.some((pattern)=>pattern.test(userAgent))) {\n            return false;\n        }\n        return suspiciousPatterns.some((pattern)=>pattern.test(userAgent));\n    }\n    /**\n   * Log security event\n   */ logSecurityEvent(event, context, details) {\n        const logEntry = {\n            timestamp: new Date().toISOString(),\n            event,\n            requestId: context.requestId,\n            ip: context.ipAddress,\n            userAgent: context.userAgent,\n            details\n        };\n        console.log(\"[SECURITY]\", JSON.stringify(logEntry));\n    }\n}\nconst security = SecurityService.getInstance();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (security);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXdCLEVBQUVDLE9BQWEsRUFBUTtRQUM3RSxNQUFNQyxXQUFXO1lBQ2ZsRSxXQUFXLElBQUlDLE9BQU9rRSxXQUFXO1lBQ2pDSjtZQUNBbkUsV0FBV29FLFFBQVFwRSxTQUFTO1lBQzVCNkQsSUFBSU8sUUFBUWxFLFNBQVM7WUFDckJDLFdBQVdpRSxRQUFRakUsU0FBUztZQUM1QmtFO1FBQ0Y7UUFFQUcsUUFBUUMsR0FBRyxDQUFDLGNBQWNDLEtBQUtDLFNBQVMsQ0FBQ0w7SUFDM0M7QUFDRjtBQUVPLE1BQU1NLFdBQVdoRyxnQkFBZ0JNLFdBQVcsR0FBRztBQUN0RCxpRUFBZTBGLFFBQVFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbGVhcGVyZngvYXBpLy4vbGliL3NlY3VyaXR5LnRzPzE5MGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTZWN1cml0eSB1dGlsaXRpZXMgZm9yIExlYXBlckZYIEJhY2tlbmQgQVBJXG4gKi9cblxuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XG5pbXBvcnQgeyBTZWN1cml0eUNvbnRleHQsIFZhbGlkYXRpb25FcnJvciB9IGZyb20gJy4uL3R5cGVzL2FwaSc7XG5cbmV4cG9ydCBjbGFzcyBTZWN1cml0eVNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogU2VjdXJpdHlTZXJ2aWNlO1xuICBwcml2YXRlIHNlY3JldEtleTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VjcmV0S2V5ID0gcHJvY2Vzcy5lbnYuQVBJX1NFQ1JFVF9LRVkgfHwgJ2ZhbGxiYWNrLWRldi1rZXktY2hhbmdlLWluLXByb2R1Y3Rpb24nO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFNlY3VyaXR5U2VydmljZSB7XG4gICAgaWYgKCFTZWN1cml0eVNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIFNlY3VyaXR5U2VydmljZS5pbnN0YW5jZSA9IG5ldyBTZWN1cml0eVNlcnZpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIFNlY3VyaXR5U2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVuaXF1ZSByZXF1ZXN0IElEXG4gICAqL1xuICBnZW5lcmF0ZVJlcXVlc3RJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB1dWlkdjQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGNsaWVudCBJUCBhZGRyZXNzIGZyb20gcmVxdWVzdFxuICAgKi9cbiAgZ2V0Q2xpZW50SVAocmVxOiBOZXh0QXBpUmVxdWVzdCk6IHN0cmluZyB7XG4gICAgY29uc3QgZm9yd2FyZGVkID0gcmVxLmhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddO1xuICAgIGNvbnN0IHJlYWxJUCA9IHJlcS5oZWFkZXJzWyd4LXJlYWwtaXAnXTtcbiAgICBjb25zdCBjZkNvbm5lY3RpbmdJUCA9IHJlcS5oZWFkZXJzWydjZi1jb25uZWN0aW5nLWlwJ107XG5cbiAgICBpZiAodHlwZW9mIGZvcndhcmRlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmb3J3YXJkZWQuc3BsaXQoJywnKVswXS50cmltKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWFsSVAgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcmVhbElQO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2ZDb25uZWN0aW5nSVAgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2ZDb25uZWN0aW5nSVA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcS5zb2NrZXQucmVtb3RlQWRkcmVzcyB8fCAndW5rbm93bic7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHNlY3VyaXR5IGNvbnRleHQgZm9yIHJlcXVlc3RcbiAgICovXG4gIGNyZWF0ZVNlY3VyaXR5Q29udGV4dChyZXE6IE5leHRBcGlSZXF1ZXN0KTogU2VjdXJpdHlDb250ZXh0IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWVzdElkOiB0aGlzLmdlbmVyYXRlUmVxdWVzdElkKCksXG4gICAgICBjbGllbnRJZDogcmVxLmhlYWRlcnNbJ3gtY2xpZW50LWlkJ10gYXMgc3RyaW5nLFxuICAgICAgaXBBZGRyZXNzOiB0aGlzLmdldENsaWVudElQKHJlcSksXG4gICAgICB1c2VyQWdlbnQ6IHJlcS5oZWFkZXJzWyd1c2VyLWFnZW50J10gfHwgJ3Vua25vd24nLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgcmF0ZUxpbWl0SW5mbzoge1xuICAgICAgICBsaW1pdDogMTAwMCxcbiAgICAgICAgcmVtYWluaW5nOiA5OTksXG4gICAgICAgIHJlc2V0OiBEYXRlLm5vdygpICsgNjAwMDBcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIEFQSSBrZXkgZnJvbSBoZWFkZXJzXG4gICAqL1xuICB2YWxpZGF0ZUFwaUtleShyZXE6IE5leHRBcGlSZXF1ZXN0KTogYm9vbGVhbiB7XG4gICAgY29uc3QgYXBpS2V5ID0gcmVxLmhlYWRlcnNbJ3gtYXBpLWtleSddIHx8IHJlcS5oZWFkZXJzWydhdXRob3JpemF0aW9uJ10/LnJlcGxhY2UoJ0JlYXJlciAnLCAnJyk7XG5cbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgYWxsb3cgcmVxdWVzdHMgd2l0aG91dCBBUEkga2V5XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFhcGlLZXkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZvciBwcm9kdWN0aW9uLCBpbXBsZW1lbnQgcHJvcGVyIEFQSSBrZXkgdmFsaWRhdGlvblxuICAgIGlmICghYXBpS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2ltcGxlIHZhbGlkYXRpb24gLSByZXBsYWNlIHdpdGggcHJvcGVyIEpXVCBvciBBUEkga2V5IHN5c3RlbVxuICAgIHJldHVybiBhcGlLZXkgPT09IHRoaXMuc2VjcmV0S2V5IHx8IGFwaUtleSA9PT0gcHJvY2Vzcy5lbnYuQVBJX1NFQ1JFVF9LRVk7XG4gIH1cblxuICAvKipcbiAgICogU2FuaXRpemUgaW5wdXQgdG8gcHJldmVudCBYU1MgYW5kIGluamVjdGlvbiBhdHRhY2tzXG4gICAqL1xuICBzYW5pdGl6ZUlucHV0KGlucHV0OiBhbnkpOiBhbnkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gaW5wdXRcbiAgICAgICAgLnJlcGxhY2UoL1s8Pl0vZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9qYXZhc2NyaXB0Oi9naSwgJycpXG4gICAgICAgIC5yZXBsYWNlKC9vblxcdys9L2dpLCAnJylcbiAgICAgICAgLnRyaW0oKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHJldHVybiBpbnB1dC5tYXAoaXRlbSA9PiB0aGlzLnNhbml0aXplSW5wdXQoaXRlbSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzYW5pdGl6ZWQ6IGFueSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgICAgIHNhbml0aXplZFt0aGlzLnNhbml0aXplSW5wdXQoa2V5KV0gPSB0aGlzLnNhbml0aXplSW5wdXQodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNhbml0aXplZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAqL1xuICB2YWxpZGF0ZVJlcXVlc3QocmVxOiBOZXh0QXBpUmVxdWVzdCwgc2NoZW1hOiBhbnkpOiBWYWxpZGF0aW9uRXJyb3JbXSB7XG4gICAgY29uc3QgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXSA9IFtdO1xuICAgIGNvbnN0IGRhdGEgPSB7IC4uLnJlcS5xdWVyeSwgLi4ucmVxLmJvZHkgfTtcblxuICAgIGZvciAoY29uc3QgW2ZpZWxkLCBydWxlc10gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2ZpZWxkXTtcbiAgICAgIGNvbnN0IGZpZWxkUnVsZXMgPSBydWxlcyBhcyBhbnk7XG5cbiAgICAgIGlmIChmaWVsZFJ1bGVzLnJlcXVpcmVkICYmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgIG1lc3NhZ2U6IGAke2ZpZWxkfSBpcyByZXF1aXJlZGAsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBmaWVsZFJ1bGVzLnR5cGUpIHtcbiAgICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gJ2FycmF5JyA6IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKGFjdHVhbFR5cGUgIT09IGZpZWxkUnVsZXMudHlwZSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgbWVzc2FnZTogYCR7ZmllbGR9IG11c3QgYmUgb2YgdHlwZSAke2ZpZWxkUnVsZXMudHlwZX1gLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGRSdWxlcy5taW5MZW5ndGggJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPCBmaWVsZFJ1bGVzLm1pbkxlbmd0aCkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgZmllbGQsXG4gICAgICAgICAgbWVzc2FnZTogYCR7ZmllbGR9IG11c3QgYmUgYXQgbGVhc3QgJHtmaWVsZFJ1bGVzLm1pbkxlbmd0aH0gY2hhcmFjdGVyc2AsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZFJ1bGVzLm1heExlbmd0aCAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IGZpZWxkUnVsZXMubWF4TGVuZ3RoKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICBtZXNzYWdlOiBgJHtmaWVsZH0gbXVzdCBiZSBubyBtb3JlIHRoYW4gJHtmaWVsZFJ1bGVzLm1heExlbmd0aH0gY2hhcmFjdGVyc2AsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZFJ1bGVzLnBhdHRlcm4gJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhZmllbGRSdWxlcy5wYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICBtZXNzYWdlOiBgJHtmaWVsZH0gZm9ybWF0IGlzIGludmFsaWRgLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGRSdWxlcy5lbnVtICYmICFmaWVsZFJ1bGVzLmVudW0uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICBtZXNzYWdlOiBgJHtmaWVsZH0gbXVzdCBiZSBvbmUgb2Y6ICR7ZmllbGRSdWxlcy5lbnVtLmpvaW4oJywgJyl9YCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzZWN1cml0eSBoZWFkZXJzXG4gICAqL1xuICBzZXRTZWN1cml0eUhlYWRlcnMocmVzOiBOZXh0QXBpUmVzcG9uc2UpOiB2b2lkIHtcbiAgICByZXMuc2V0SGVhZGVyKCdYLUNvbnRlbnQtVHlwZS1PcHRpb25zJywgJ25vc25pZmYnKTtcbiAgICByZXMuc2V0SGVhZGVyKCdYLUZyYW1lLU9wdGlvbnMnLCAnREVOWScpO1xuICAgIHJlcy5zZXRIZWFkZXIoJ1gtWFNTLVByb3RlY3Rpb24nLCAnMTsgbW9kZT1ibG9jaycpO1xuICAgIHJlcy5zZXRIZWFkZXIoJ1JlZmVycmVyLVBvbGljeScsICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyk7XG4gICAgcmVzLnNldEhlYWRlcignQ29udGVudC1TZWN1cml0eS1Qb2xpY3knLCBcImRlZmF1bHQtc3JjICdzZWxmJ1wiKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXMuc2V0SGVhZGVyKCdTdHJpY3QtVHJhbnNwb3J0LVNlY3VyaXR5JywgJ21heC1hZ2U9MzE1MzYwMDA7IGluY2x1ZGVTdWJEb21haW5zJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlcXVlc3QgaXMgZnJvbSBhbGxvd2VkIG9yaWdpblxuICAgKi9cbiAgaXNPcmlnaW5BbGxvd2VkKG9yaWdpbjogc3RyaW5nIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgaWYgKCFvcmlnaW4pIHJldHVybiB0cnVlOyAvLyBBbGxvdyBzYW1lLW9yaWdpbiByZXF1ZXN0c1xuXG4gICAgY29uc3QgYWxsb3dlZE9yaWdpbnMgPSBbXG4gICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyxcbiAgICAgICdodHRwOi8vbG9jYWxob3N0OjUxNzMnLFxuICAgICAgJ2h0dHBzOi8vbGVhcGVyZngtZGFzaGJvYXJkLnZlcmNlbC5hcHAnLFxuICAgICAgcHJvY2Vzcy5lbnYuQ09SU19PUklHSU5cbiAgICBdLmZpbHRlcihCb29sZWFuKTtcblxuICAgIHJldHVybiBhbGxvd2VkT3JpZ2lucy5pbmNsdWRlcyhvcmlnaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIENPUlMgaGVhZGVyc1xuICAgKi9cbiAgZ2V0Q29yc0hlYWRlcnMob3JpZ2luOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBpc0FsbG93ZWQgPSB0aGlzLmlzT3JpZ2luQWxsb3dlZChvcmlnaW4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nOiBpc0FsbG93ZWQgPyAob3JpZ2luIHx8ICcqJykgOiAnbnVsbCcsXG4gICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kcyc6ICdHRVQsIFBPU1QsIFBVVCwgREVMRVRFLCBPUFRJT05TJyxcbiAgICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJzogJ0NvbnRlbnQtVHlwZSwgQXV0aG9yaXphdGlvbiwgWC1BUEktS2V5LCBYLVJlcXVlc3QtSUQsIFgtQ2xpZW50LUlEJyxcbiAgICAgICdBY2Nlc3MtQ29udHJvbC1NYXgtQWdlJzogJzg2NDAwJyxcbiAgICAgICdWYXJ5JzogJ09yaWdpbidcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJhdGUgbGltaXRpbmcga2V5IGdlbmVyYXRpb25cbiAgICovXG4gIGdldFJhdGVMaW1pdEtleShyZXE6IE5leHRBcGlSZXF1ZXN0LCBwcmVmaXggPSAncmwnKTogc3RyaW5nIHtcbiAgICBjb25zdCBpcCA9IHRoaXMuZ2V0Q2xpZW50SVAocmVxKTtcbiAgICBjb25zdCBhcGlLZXkgPSByZXEuaGVhZGVyc1sneC1hcGkta2V5J10gfHwgJ2Fub255bW91cyc7XG4gICAgcmV0dXJuIGAke3ByZWZpeH06JHtpcH06JHthcGlLZXl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiByZXF1ZXN0IGlzIHN1c3BpY2lvdXNcbiAgICovXG4gIGlzU3VzcGljaW91c1JlcXVlc3QocmVxOiBOZXh0QXBpUmVxdWVzdCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IHJlcS5oZWFkZXJzWyd1c2VyLWFnZW50J10gfHwgJyc7XG4gICAgY29uc3Qgc3VzcGljaW91c1BhdHRlcm5zID0gW1xuICAgICAgL2JvdC9pLFxuICAgICAgL2NyYXdsZXIvaSxcbiAgICAgIC9zcGlkZXIvaSxcbiAgICAgIC9zY3JhcGVyL2ksXG4gICAgICAvY3VybC9pLFxuICAgICAgL3dnZXQvaSxcbiAgICAgIC9weXRob24vaSxcbiAgICAgIC9wb3N0bWFuL2lcbiAgICBdO1xuXG4gICAgLy8gQWxsb3cgbGVnaXRpbWF0ZSBjcmF3bGVycyBhbmQgZGV2ZWxvcG1lbnQgdG9vbHNcbiAgICBjb25zdCBhbGxvd2VkUGF0dGVybnMgPSBbXG4gICAgICAvZ29vZ2xlYm90L2ksXG4gICAgICAvYmluZ2JvdC9pLFxuICAgICAgL3NsYWNrYm90L2ksXG4gICAgICAvZmFjZWJvb2tleHRlcm5hbGhpdC9pLFxuICAgICAgL3R3aXR0ZXJib3QvaSxcbiAgICAgIC9saW5rZWRpbmJvdC9pLFxuICAgICAgL2Nocm9tZS9pLFxuICAgICAgL2ZpcmVmb3gvaSxcbiAgICAgIC9zYWZhcmkvaSxcbiAgICAgIC9lZGdlL2lcbiAgICBdO1xuXG4gICAgaWYgKGFsbG93ZWRQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KHVzZXJBZ2VudCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1c3BpY2lvdXNQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KHVzZXJBZ2VudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyBzZWN1cml0eSBldmVudFxuICAgKi9cbiAgbG9nU2VjdXJpdHlFdmVudChldmVudDogc3RyaW5nLCBjb250ZXh0OiBTZWN1cml0eUNvbnRleHQsIGRldGFpbHM/OiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBsb2dFbnRyeSA9IHtcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZXZlbnQsXG4gICAgICByZXF1ZXN0SWQ6IGNvbnRleHQucmVxdWVzdElkLFxuICAgICAgaXA6IGNvbnRleHQuaXBBZGRyZXNzLFxuICAgICAgdXNlckFnZW50OiBjb250ZXh0LnVzZXJBZ2VudCxcbiAgICAgIGRldGFpbHNcbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coJ1tTRUNVUklUWV0nLCBKU09OLnN0cmluZ2lmeShsb2dFbnRyeSkpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWN1cml0eSA9IFNlY3VyaXR5U2VydmljZS5nZXRJbnN0YW5jZSgpO1xuZXhwb3J0IGRlZmF1bHQgc2VjdXJpdHk7Il0sIm5hbWVzIjpbInY0IiwidXVpZHY0IiwiU2VjdXJpdHlTZXJ2aWNlIiwiY29uc3RydWN0b3IiLCJzZWNyZXRLZXkiLCJwcm9jZXNzIiwiZW52IiwiQVBJX1NFQ1JFVF9LRVkiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2VuZXJhdGVSZXF1ZXN0SWQiLCJnZXRDbGllbnRJUCIsInJlcSIsImZvcndhcmRlZCIsImhlYWRlcnMiLCJyZWFsSVAiLCJjZkNvbm5lY3RpbmdJUCIsInNwbGl0IiwidHJpbSIsInNvY2tldCIsInJlbW90ZUFkZHJlc3MiLCJjcmVhdGVTZWN1cml0eUNvbnRleHQiLCJyZXF1ZXN0SWQiLCJjbGllbnRJZCIsImlwQWRkcmVzcyIsInVzZXJBZ2VudCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJyYXRlTGltaXRJbmZvIiwibGltaXQiLCJyZW1haW5pbmciLCJyZXNldCIsInZhbGlkYXRlQXBpS2V5IiwiYXBpS2V5IiwicmVwbGFjZSIsInNhbml0aXplSW5wdXQiLCJpbnB1dCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIml0ZW0iLCJzYW5pdGl6ZWQiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ2YWxpZGF0ZVJlcXVlc3QiLCJzY2hlbWEiLCJlcnJvcnMiLCJkYXRhIiwicXVlcnkiLCJib2R5IiwiZmllbGQiLCJydWxlcyIsImZpZWxkUnVsZXMiLCJyZXF1aXJlZCIsInVuZGVmaW5lZCIsInB1c2giLCJtZXNzYWdlIiwidHlwZSIsImFjdHVhbFR5cGUiLCJtaW5MZW5ndGgiLCJsZW5ndGgiLCJtYXhMZW5ndGgiLCJwYXR0ZXJuIiwidGVzdCIsImVudW0iLCJpbmNsdWRlcyIsImpvaW4iLCJzZXRTZWN1cml0eUhlYWRlcnMiLCJyZXMiLCJzZXRIZWFkZXIiLCJpc09yaWdpbkFsbG93ZWQiLCJvcmlnaW4iLCJhbGxvd2VkT3JpZ2lucyIsIkNPUlNfT1JJR0lOIiwiZmlsdGVyIiwiQm9vbGVhbiIsImdldENvcnNIZWFkZXJzIiwiaXNBbGxvd2VkIiwiZ2V0UmF0ZUxpbWl0S2V5IiwicHJlZml4IiwiaXAiLCJpc1N1c3BpY2lvdXNSZXF1ZXN0Iiwic3VzcGljaW91c1BhdHRlcm5zIiwiYWxsb3dlZFBhdHRlcm5zIiwic29tZSIsImxvZ1NlY3VyaXR5RXZlbnQiLCJldmVudCIsImNvbnRleHQiLCJkZXRhaWxzIiwibG9nRW50cnkiLCJ0b0lTT1N0cmluZyIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5Iiwic2VjdXJpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/security.ts\n");

/***/ }),

/***/ "(api)/./pages/api/rates/current.ts":
/*!************************************!*\
  !*** ./pages/api/rates/current.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get */ \"(api)/./pages/api/rates/get.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_get__WEBPACK_IMPORTED_MODULE_0__]);\n_get__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n * Current Exchange Rates API Endpoint\n * Alias for get.ts - retrieves current exchange rates for frontend applications\n */ \n// Simple forwarding to the get endpoint\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_get__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvcmF0ZXMvY3VycmVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Q0FHQyxHQUcyQjtBQUU1Qix3Q0FBd0M7QUFDeEMsaUVBQWVBLDRDQUFPQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxlYXBlcmZ4L2FwaS8uL3BhZ2VzL2FwaS9yYXRlcy9jdXJyZW50LnRzPzk0ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDdXJyZW50IEV4Y2hhbmdlIFJhdGVzIEFQSSBFbmRwb2ludFxuICogQWxpYXMgZm9yIGdldC50cyAtIHJldHJpZXZlcyBjdXJyZW50IGV4Y2hhbmdlIHJhdGVzIGZvciBmcm9udGVuZCBhcHBsaWNhdGlvbnNcbiAqL1xuXG5pbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XG5pbXBvcnQgaGFuZGxlciBmcm9tICcuL2dldCc7XG5cbi8vIFNpbXBsZSBmb3J3YXJkaW5nIHRvIHRoZSBnZXQgZW5kcG9pbnRcbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7Il0sIm5hbWVzIjpbImhhbmRsZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/rates/current.ts\n");

/***/ }),

/***/ "(api)/./pages/api/rates/get.ts":
/*!********************************!*\
  !*** ./pages/api/rates/get.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_security__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../lib/security */ \"(api)/./lib/security.ts\");\n/* harmony import */ var _lib_rate_limiter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/rate-limiter */ \"(api)/./lib/rate-limiter.ts\");\n/* harmony import */ var _lib_rate_engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../lib/rate-engine */ \"(api)/./lib/rate-engine.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_security__WEBPACK_IMPORTED_MODULE_0__, _lib_rate_limiter__WEBPACK_IMPORTED_MODULE_1__, _lib_rate_engine__WEBPACK_IMPORTED_MODULE_2__]);\n([_lib_security__WEBPACK_IMPORTED_MODULE_0__, _lib_rate_limiter__WEBPACK_IMPORTED_MODULE_1__, _lib_rate_engine__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * Get Exchange Rates API Endpoint\n * Retrieve current exchange rates for store operations\n */ \n\n\nasync function handler(req, res) {\n    const securityContext = _lib_security__WEBPACK_IMPORTED_MODULE_0__.security.createSecurityContext(req);\n    // Set security headers\n    _lib_security__WEBPACK_IMPORTED_MODULE_0__.security.setSecurityHeaders(res);\n    // Set CORS headers\n    const corsHeaders = _lib_security__WEBPACK_IMPORTED_MODULE_0__.security.getCorsHeaders(req.headers.origin);\n    Object.entries(corsHeaders).forEach(([key, value])=>{\n        res.setHeader(key, value);\n    });\n    // Handle OPTIONS preflight\n    if (req.method === \"OPTIONS\") {\n        res.status(200).end();\n        return;\n    }\n    // Only allow GET requests\n    if (req.method !== \"GET\") {\n        res.status(405).json({\n            success: false,\n            error: \"Method not allowed\",\n            timestamp: Date.now(),\n            requestId: securityContext.requestId\n        });\n        return;\n    }\n    try {\n        // Apply rate limiting\n        const canProceed = await _lib_rate_limiter__WEBPACK_IMPORTED_MODULE_1__.rateLimiter.applyRateLimit(req, res, \"rates\");\n        if (!canProceed) return;\n        // Validate API access\n        if (!_lib_security__WEBPACK_IMPORTED_MODULE_0__.security.validateApiKey(req)) {\n            res.status(401).json({\n                success: false,\n                error: \"Invalid or missing API key\",\n                timestamp: Date.now(),\n                requestId: securityContext.requestId\n            });\n            return;\n        }\n        // Sanitize and validate input\n        const { pair, storeId, all } = _lib_security__WEBPACK_IMPORTED_MODULE_0__.security.sanitizeInput(req.query);\n        // Ensure rate engine is running\n        if (!_lib_rate_engine__WEBPACK_IMPORTED_MODULE_2__.rateEngine.getStatus().isRunning) {\n            await _lib_rate_engine__WEBPACK_IMPORTED_MODULE_2__.rateEngine.start();\n        }\n        // Handle single pair request\n        if (pair) {\n            const rate = _lib_rate_engine__WEBPACK_IMPORTED_MODULE_2__.rateEngine.getRate(pair);\n            if (!rate) {\n                res.status(404).json({\n                    success: false,\n                    error: `Exchange rate not found for ${pair}`,\n                    timestamp: Date.now(),\n                    requestId: securityContext.requestId\n                });\n                return;\n            }\n            // Filter by store if specified\n            if (storeId && rate.storeId && rate.storeId !== storeId) {\n                res.status(404).json({\n                    success: false,\n                    error: `Exchange rate not found for store ${storeId}`,\n                    timestamp: Date.now(),\n                    requestId: securityContext.requestId\n                });\n                return;\n            }\n            res.status(200).json({\n                success: true,\n                data: rate,\n                timestamp: Date.now(),\n                requestId: securityContext.requestId\n            });\n            return;\n        }\n        // Handle all rates request\n        let rates = _lib_rate_engine__WEBPACK_IMPORTED_MODULE_2__.rateEngine.getAllRates();\n        // Filter by store if specified\n        if (storeId) {\n            rates = rates.filter((rate)=>!rate.storeId || rate.storeId === storeId);\n        }\n        // Filter only active rates\n        rates = rates.filter((rate)=>rate.isActive);\n        // Sort by currency pair for consistent ordering\n        rates.sort((a, b)=>{\n            const pairA = `${a.baseCurrency}${a.targetCurrency}`;\n            const pairB = `${b.baseCurrency}${b.targetCurrency}`;\n            return pairA.localeCompare(pairB);\n        });\n        res.status(200).json({\n            success: true,\n            data: rates,\n            timestamp: Date.now(),\n            requestId: securityContext.requestId\n        });\n    } catch (error) {\n        console.error(\"[Rates] Get error:\", error);\n        res.status(500).json({\n            success: false,\n            error: \"Internal server error\",\n            timestamp: Date.now(),\n            requestId: securityContext.requestId\n        });\n    }\n}\nconst config = {\n    api: {\n        responseLimit: \"8mb\"\n    }\n};\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3RDO1lBQ0E7UUFDRjtRQUVBLDJCQUEyQjtRQUMzQixJQUFJZSxRQUFRekMsd0RBQVVBLENBQUMwQyxXQUFXO1FBRWxDLCtCQUErQjtRQUMvQixJQUFJWCxTQUFTO1lBQ1hVLFFBQVFBLE1BQU1FLE1BQU0sQ0FBQ0wsQ0FBQUEsT0FBUSxDQUFDQSxLQUFLUCxPQUFPLElBQUlPLEtBQUtQLE9BQU8sS0FBS0E7UUFDakU7UUFFQSwyQkFBMkI7UUFDM0JVLFFBQVFBLE1BQU1FLE1BQU0sQ0FBQ0wsQ0FBQUEsT0FBUUEsS0FBS00sUUFBUTtRQUUxQyxnREFBZ0Q7UUFDaERILE1BQU1JLElBQUksQ0FBQyxDQUFDQyxHQUFHQztZQUNiLE1BQU1DLFFBQVEsQ0FBQyxFQUFFRixFQUFFRyxZQUFZLENBQUMsRUFBRUgsRUFBRUksY0FBYyxDQUFDLENBQUM7WUFDcEQsTUFBTUMsUUFBUSxDQUFDLEVBQUVKLEVBQUVFLFlBQVksQ0FBQyxFQUFFRixFQUFFRyxjQUFjLENBQUMsQ0FBQztZQUNwRCxPQUFPRixNQUFNSSxhQUFhLENBQUNEO1FBQzdCO1FBRUFoRCxJQUFJZSxNQUFNLENBQUMsS0FBS0UsSUFBSSxDQUFDO1lBQ25CQyxTQUFTO1lBQ1RtQixNQUFNQztZQUNObEIsV0FBV0MsS0FBS0MsR0FBRztZQUNuQkMsV0FBV3RCLGdCQUFnQnNCLFNBQVM7UUFDdEM7SUFFRixFQUFFLE9BQU9KLE9BQU87UUFDZCtCLFFBQVEvQixLQUFLLENBQUMsc0JBQXNCQTtRQUVwQ25CLElBQUllLE1BQU0sQ0FBQyxLQUFLRSxJQUFJLENBQUM7WUFDbkJDLFNBQVM7WUFDVEMsT0FBTztZQUNQQyxXQUFXQyxLQUFLQyxHQUFHO1lBQ25CQyxXQUFXdEIsZ0JBQWdCc0IsU0FBUztRQUN0QztJQUNGO0FBQ0Y7QUFFTyxNQUFNNEIsU0FBUztJQUNwQkMsS0FBSztRQUNIQyxlQUFlO0lBQ2pCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BsZWFwZXJmeC9hcGkvLi9wYWdlcy9hcGkvcmF0ZXMvZ2V0LnRzPzhkNGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHZXQgRXhjaGFuZ2UgUmF0ZXMgQVBJIEVuZHBvaW50XG4gKiBSZXRyaWV2ZSBjdXJyZW50IGV4Y2hhbmdlIHJhdGVzIGZvciBzdG9yZSBvcGVyYXRpb25zXG4gKi9cblxuaW1wb3J0IHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnO1xuaW1wb3J0IHsgQXBpUmVzcG9uc2UgfSBmcm9tICcuLi8uLi8uLi90eXBlcy9hcGknO1xuaW1wb3J0IHsgRXhjaGFuZ2VSYXRlIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMvcmF0ZXMnO1xuaW1wb3J0IHsgc2VjdXJpdHkgfSBmcm9tICcuLi8uLi8uLi9saWIvc2VjdXJpdHknO1xuaW1wb3J0IHsgcmF0ZUxpbWl0ZXIgfSBmcm9tICcuLi8uLi8uLi9saWIvcmF0ZS1saW1pdGVyJztcbmltcG9ydCB7IHJhdGVFbmdpbmUgfSBmcm9tICcuLi8uLi8uLi9saWIvcmF0ZS1lbmdpbmUnO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxBcGlSZXNwb25zZTxFeGNoYW5nZVJhdGUgfCBFeGNoYW5nZVJhdGVbXT4+XG4pIHtcbiAgY29uc3Qgc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHkuY3JlYXRlU2VjdXJpdHlDb250ZXh0KHJlcSk7XG5cbiAgLy8gU2V0IHNlY3VyaXR5IGhlYWRlcnNcbiAgc2VjdXJpdHkuc2V0U2VjdXJpdHlIZWFkZXJzKHJlcyk7XG5cbiAgLy8gU2V0IENPUlMgaGVhZGVyc1xuICBjb25zdCBjb3JzSGVhZGVycyA9IHNlY3VyaXR5LmdldENvcnNIZWFkZXJzKHJlcS5oZWFkZXJzLm9yaWdpbik7XG4gIE9iamVjdC5lbnRyaWVzKGNvcnNIZWFkZXJzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICByZXMuc2V0SGVhZGVyKGtleSwgdmFsdWUpO1xuICB9KTtcblxuICAvLyBIYW5kbGUgT1BUSU9OUyBwcmVmbGlnaHRcbiAgaWYgKHJlcS5tZXRob2QgPT09ICdPUFRJT05TJykge1xuICAgIHJlcy5zdGF0dXMoMjAwKS5lbmQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPbmx5IGFsbG93IEdFVCByZXF1ZXN0c1xuICBpZiAocmVxLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICByZXMuc3RhdHVzKDQwNSkuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnTWV0aG9kIG5vdCBhbGxvd2VkJyxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHJlcXVlc3RJZDogc2VjdXJpdHlDb250ZXh0LnJlcXVlc3RJZCxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIC8vIEFwcGx5IHJhdGUgbGltaXRpbmdcbiAgICBjb25zdCBjYW5Qcm9jZWVkID0gYXdhaXQgcmF0ZUxpbWl0ZXIuYXBwbHlSYXRlTGltaXQocmVxLCByZXMsICdyYXRlcycpO1xuICAgIGlmICghY2FuUHJvY2VlZCkgcmV0dXJuO1xuXG4gICAgLy8gVmFsaWRhdGUgQVBJIGFjY2Vzc1xuICAgIGlmICghc2VjdXJpdHkudmFsaWRhdGVBcGlLZXkocmVxKSkge1xuICAgICAgcmVzLnN0YXR1cyg0MDEpLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdJbnZhbGlkIG9yIG1pc3NpbmcgQVBJIGtleScsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgcmVxdWVzdElkOiBzZWN1cml0eUNvbnRleHQucmVxdWVzdElkLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2FuaXRpemUgYW5kIHZhbGlkYXRlIGlucHV0XG4gICAgY29uc3QgeyBwYWlyLCBzdG9yZUlkLCBhbGwgfSA9IHNlY3VyaXR5LnNhbml0aXplSW5wdXQocmVxLnF1ZXJ5KTtcblxuICAgIC8vIEVuc3VyZSByYXRlIGVuZ2luZSBpcyBydW5uaW5nXG4gICAgaWYgKCFyYXRlRW5naW5lLmdldFN0YXR1cygpLmlzUnVubmluZykge1xuICAgICAgYXdhaXQgcmF0ZUVuZ2luZS5zdGFydCgpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzaW5nbGUgcGFpciByZXF1ZXN0XG4gICAgaWYgKHBhaXIpIHtcbiAgICAgIGNvbnN0IHJhdGUgPSByYXRlRW5naW5lLmdldFJhdGUocGFpcik7XG5cbiAgICAgIGlmICghcmF0ZSkge1xuICAgICAgICByZXMuc3RhdHVzKDQwNCkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGBFeGNoYW5nZSByYXRlIG5vdCBmb3VuZCBmb3IgJHtwYWlyfWAsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHJlcXVlc3RJZDogc2VjdXJpdHlDb250ZXh0LnJlcXVlc3RJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIGJ5IHN0b3JlIGlmIHNwZWNpZmllZFxuICAgICAgaWYgKHN0b3JlSWQgJiYgcmF0ZS5zdG9yZUlkICYmIHJhdGUuc3RvcmVJZCAhPT0gc3RvcmVJZCkge1xuICAgICAgICByZXMuc3RhdHVzKDQwNCkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGBFeGNoYW5nZSByYXRlIG5vdCBmb3VuZCBmb3Igc3RvcmUgJHtzdG9yZUlkfWAsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHJlcXVlc3RJZDogc2VjdXJpdHlDb250ZXh0LnJlcXVlc3RJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiByYXRlLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIHJlcXVlc3RJZDogc2VjdXJpdHlDb250ZXh0LnJlcXVlc3RJZCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBhbGwgcmF0ZXMgcmVxdWVzdFxuICAgIGxldCByYXRlcyA9IHJhdGVFbmdpbmUuZ2V0QWxsUmF0ZXMoKTtcblxuICAgIC8vIEZpbHRlciBieSBzdG9yZSBpZiBzcGVjaWZpZWRcbiAgICBpZiAoc3RvcmVJZCkge1xuICAgICAgcmF0ZXMgPSByYXRlcy5maWx0ZXIocmF0ZSA9PiAhcmF0ZS5zdG9yZUlkIHx8IHJhdGUuc3RvcmVJZCA9PT0gc3RvcmVJZCk7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIG9ubHkgYWN0aXZlIHJhdGVzXG4gICAgcmF0ZXMgPSByYXRlcy5maWx0ZXIocmF0ZSA9PiByYXRlLmlzQWN0aXZlKTtcblxuICAgIC8vIFNvcnQgYnkgY3VycmVuY3kgcGFpciBmb3IgY29uc2lzdGVudCBvcmRlcmluZ1xuICAgIHJhdGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHBhaXJBID0gYCR7YS5iYXNlQ3VycmVuY3l9JHthLnRhcmdldEN1cnJlbmN5fWA7XG4gICAgICBjb25zdCBwYWlyQiA9IGAke2IuYmFzZUN1cnJlbmN5fSR7Yi50YXJnZXRDdXJyZW5jeX1gO1xuICAgICAgcmV0dXJuIHBhaXJBLmxvY2FsZUNvbXBhcmUocGFpckIpO1xuICAgIH0pO1xuXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHJhdGVzLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgcmVxdWVzdElkOiBzZWN1cml0eUNvbnRleHQucmVxdWVzdElkLFxuICAgIH0pO1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1JhdGVzXSBHZXQgZXJyb3I6JywgZXJyb3IpO1xuXG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICByZXF1ZXN0SWQ6IHNlY3VyaXR5Q29udGV4dC5yZXF1ZXN0SWQsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcbiAgYXBpOiB7XG4gICAgcmVzcG9uc2VMaW1pdDogJzhtYicsXG4gIH0sXG59OyJdLCJuYW1lcyI6WyJzZWN1cml0eSIsInJhdGVMaW1pdGVyIiwicmF0ZUVuZ2luZSIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJzZWN1cml0eUNvbnRleHQiLCJjcmVhdGVTZWN1cml0eUNvbnRleHQiLCJzZXRTZWN1cml0eUhlYWRlcnMiLCJjb3JzSGVhZGVycyIsImdldENvcnNIZWFkZXJzIiwiaGVhZGVycyIsIm9yaWdpbiIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJzZXRIZWFkZXIiLCJtZXRob2QiLCJzdGF0dXMiLCJlbmQiLCJqc29uIiwic3VjY2VzcyIsImVycm9yIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInJlcXVlc3RJZCIsImNhblByb2NlZWQiLCJhcHBseVJhdGVMaW1pdCIsInZhbGlkYXRlQXBpS2V5IiwicGFpciIsInN0b3JlSWQiLCJhbGwiLCJzYW5pdGl6ZUlucHV0IiwicXVlcnkiLCJnZXRTdGF0dXMiLCJpc1J1bm5pbmciLCJzdGFydCIsInJhdGUiLCJnZXRSYXRlIiwiZGF0YSIsInJhdGVzIiwiZ2V0QWxsUmF0ZXMiLCJmaWx0ZXIiLCJpc0FjdGl2ZSIsInNvcnQiLCJhIiwiYiIsInBhaXJBIiwiYmFzZUN1cnJlbmN5IiwidGFyZ2V0Q3VycmVuY3kiLCJwYWlyQiIsImxvY2FsZUNvbXBhcmUiLCJjb25zb2xlIiwiY29uZmlnIiwiYXBpIiwicmVzcG9uc2VMaW1pdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/rates/get.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Frates%2Fcurrent&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Frates%2Fcurrent.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();