"use strict";exports.id=704,exports.ids=[704],exports.modules={2057:(e,t,s)=>{s.a(e,async(e,a)=>{try{s.d(t,{Vy:()=>o});var i=s(936),r=e([i]);i=(r.then?(await r)():r)[0];class n{constructor(){this.isRunning=!1,this.rates=new Map,this.thresholds=new Map,this.alerts=[],this.lastUpdate=0,this.sources=new Set(["polygon","twelvedata","coinbase"]),this.subscribers=new Set,this.config={defaultSpread:.02,minSpread:.005,maxSpread:.1,volatilityFactor:.1,liquidityFactor:.05,updateFrequency:3e4}}static getInstance(){return n.instance||(n.instance=new n),n.instance}async start(){if(this.isRunning){console.log("[RateEngine] Already running");return}console.log("[RateEngine] Starting rate engine...");try{await this.loadConfiguration(),this.updateInterval=setInterval(()=>{this.updateRates().catch(e=>{console.error("[RateEngine] Update cycle error:",e)})},this.config.updateFrequency),await this.updateRates(),this.isRunning=!0,console.log("[RateEngine] Started successfully")}catch(e){throw console.error("[RateEngine] Failed to start:",e),e}}stop(){this.isRunning&&(console.log("[RateEngine] Stopping rate engine..."),this.updateInterval&&(clearInterval(this.updateInterval),this.updateInterval=void 0),this.isRunning=!1,console.log("[RateEngine] Stopped"))}async loadConfiguration(){try{let e=await i.Fs.get("rates:all");if(e){let t=JSON.parse(e);t.forEach(e=>{this.rates.set(e.baseCurrency+e.targetCurrency,e)})}let t=await i.Fs.get("thresholds:all");if(t){let e=JSON.parse(t);e.forEach(e=>{this.thresholds.set(e.currencyPair,e)})}let s=await i.Fs.get("rate_engine:config");s&&(this.config={...this.config,...JSON.parse(s)})}catch(e){console.error("[RateEngine] Error loading configuration:",e)}}async saveConfiguration(){try{let e=Array.from(this.rates.values()),t=Array.from(this.thresholds.values());await Promise.all([i.Fs.setex("rates:all",3600,JSON.stringify(e)),i.Fs.setex("thresholds:all",3600,JSON.stringify(t)),i.Fs.setex("rate_engine:config",3600,JSON.stringify(this.config))])}catch(e){console.error("[RateEngine] Error saving configuration:",e)}}async updateRates(){let e=Date.now();try{console.log("[RateEngine] Updating rates...");let t=this.getCurrencyPairs();for(let e of t)await this.updateRateForPair(e);await this.saveConfiguration(),this.checkThresholds(),this.lastUpdate=Date.now();let s=this.lastUpdate-e;console.log(`[RateEngine] Updated ${t.length} rates in ${s}ms`)}catch(e){console.error("[RateEngine] Error updating rates:",e)}}async updateRateForPair(e){try{let[t,s]=e.split("/"),a=await this.getMarketData(t,s);if(!a){console.warn(`[RateEngine] No market data for ${e}`);return}let r=this.calculateRateWithSpread(a,e);this.rates.set(e.replace("/",""),r),await i.Fs.setex(`rate:${e.replace("/","")}`,60,JSON.stringify(r))}catch(t){console.error(`[RateEngine] Error updating rate for ${e}:`,t)}}async getMarketData(e,t){try{for(let s of this.sources){let a=await this.fetchFromSource(s,e,t);if(a)return a}return null}catch(s){return console.error(`[RateEngine] Error getting market data for ${e}/${t}:`,s),null}}async fetchFromSource(e,t,s){try{switch(e){case"coinbase":return await this.fetchCoinbaseData(t,s);case"polygon":return await this.fetchPolygonData(t,s);case"twelvedata":return await this.fetchTwelveDataData(t,s);default:return null}}catch(t){return console.error(`[RateEngine] Error fetching from ${e}:`,t),null}}async fetchCoinbaseData(e,t){try{let s=`${e}-${t}`,a=await fetch(`https://api.exchange.coinbase.com/products/${s}/ticker`);if(!a.ok)return null;let i=await a.json();return{symbol:s,price:parseFloat(i.price),timestamp:Date.now(),bid:parseFloat(i.bid),ask:parseFloat(i.ask),volume:parseFloat(i.volume),source:"coinbase"}}catch(e){return null}}async fetchPolygonData(e,t){return null}async fetchTwelveDataData(e,t){return null}calculateRateWithSpread(e,t){let s=this.thresholds.get(t),a=s?(s.minSpread+s.maxSpread)/2:this.config.defaultSpread,i=this.calculateVolatilitySpread(e),r=Math.max(Math.min(a+i,this.config.maxSpread),this.config.minSpread),n=e.price*(1+r/2),o=e.price*(1-r/2);return{id:`${t}_${Date.now()}`,baseCurrency:t.split("/")[0]||t.slice(0,3),targetCurrency:t.split("/")[1]||t.slice(3),rate:e.price,spread:r,buyRate:n,sellRate:o,timestamp:e.timestamp,source:"calculated",isActive:!0,lastUpdated:Date.now()}}calculateVolatilitySpread(e){if(!e.changePercent24h)return 0;let t=Math.abs(e.changePercent24h/100);return t*this.config.volatilityFactor}checkThresholds(){for(let[e,t]of this.thresholds){let s=this.rates.get(e.replace("/",""));if(!s)continue;(s.spread<t.minSpread||s.spread>t.maxSpread)&&this.generateAlert({id:`alert_${Date.now()}_${e}`,currencyPair:e,alertType:"threshold_breach",message:`Spread ${(100*s.spread).toFixed(2)}% outside threshold range ${(100*t.minSpread).toFixed(2)}%-${(100*t.maxSpread).toFixed(2)}%`,severity:"medium",timestamp:Date.now(),acknowledged:!1});let a=(Date.now()-s.lastUpdated)/6e4;a>5&&this.generateAlert({id:`alert_${Date.now()}_stale_${e}`,currencyPair:e,alertType:"rate_stale",message:`Rate for ${e} is ${a.toFixed(1)} minutes old`,severity:a>15?"high":"medium",timestamp:Date.now(),acknowledged:!1})}}generateAlert(e){this.alerts.push(e),console.warn(`[RateEngine] Alert: ${e.message}`),this.alerts.length>100&&(this.alerts=this.alerts.slice(-100))}getCurrencyPairs(){return["USD/CAD","EUR/USD","GBP/USD","USD/JPY","AUD/USD","USD/CHF","BTC/USD","ETH/USD","BTC/CAD","ETH/CAD"]}getRate(e){return this.rates.get(e.replace("/",""))||null}getAllRates(){return Array.from(this.rates.values())}async updateRateManually(e){let t=e.currencyPair.replace("/",""),s=this.rates.get(t);if(!s)throw Error(`Rate not found for ${e.currencyPair}`);let a={...s,spread:e.spread||s.spread,buyRate:e.buyRate||s.buyRate,sellRate:e.sellRate||s.sellRate,source:e.source,lastUpdated:Date.now(),storeId:e.storeId};if(a.spread<this.config.minSpread||a.spread>this.config.maxSpread)throw Error(`Spread ${(100*a.spread).toFixed(2)}% outside allowed range ${(100*this.config.minSpread).toFixed(2)}%-${(100*this.config.maxSpread).toFixed(2)}%`);return this.rates.set(t,a),await i.Fs.setex(`rate:${t}`,3600,JSON.stringify(a)),a}async addThreshold(e){this.thresholds.set(e.currencyPair,e),await this.saveConfiguration()}getStatus(){return{isRunning:this.isRunning,lastUpdate:this.lastUpdate,activeSources:Array.from(this.sources),activeSubscriptions:this.subscribers.size,rateCount:this.rates.size,alertCount:this.alerts.length,lockCount:0,performance:{avgUpdateTime:0,maxUpdateTime:0,errorRate:0}}}subscribe(e){this.subscribers.add(e)}unsubscribe(e){this.subscribers.delete(e)}getAlerts(e=50){return this.alerts.slice(-e)}}let o=n.getInstance();a()}catch(e){a(e)}})},704:(e,t,s)=>{s.a(e,async(e,a)=>{try{s.d(t,{r6:()=>c});var i=s(6555),r=s(2057),n=e([i,r]);[i,r]=n.then?(await n)():n;class o{constructor(){this.hub={clients:new Map,subscriptions:new Map,messageQueue:[],isRunning:!1,stats:{totalConnections:0,activeConnections:0,messagesSent:0,messagesReceived:0,errors:0}}}static getInstance(){return o.instance||(o.instance=new o),o.instance}start(){if(this.hub.isRunning){console.log("[WebSocketHub] Already running");return}console.log("[WebSocketHub] Starting WebSocket hub..."),this.heartbeatInterval=setInterval(()=>{this.sendHeartbeat()},3e4),this.cleanupInterval=setInterval(()=>{this.cleanupStaleConnections()},6e4),this.hub.isRunning=!0,console.log("[WebSocketHub] Started successfully")}stop(){if(this.hub.isRunning){for(let e of(console.log("[WebSocketHub] Stopping WebSocket hub..."),this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=void 0),this.cleanupInterval&&(clearInterval(this.cleanupInterval),this.cleanupInterval=void 0),this.hub.clients.values()))this.disconnectClient(e.id,"Server shutdown");this.hub.isRunning=!1,console.log("[WebSocketHub] Stopped")}}handleConnection(e,t){let s=(0,i.v4)(),a={id:s,socket:e,subscriptions:[],connectedAt:Date.now(),lastActivity:Date.now(),isActive:!0,userAgent:t.headers["user-agent"],ipAddress:this.getClientIP(t)};return this.hub.clients.set(s,a),this.hub.stats.totalConnections++,this.hub.stats.activeConnections++,console.log(`[WebSocketHub] Client connected: ${s}`),e.on("message",e=>{this.handleMessage(s,e.toString())}),e.on("close",()=>{this.disconnectClient(s,"Client disconnected")}),e.on("error",e=>{console.error(`[WebSocketHub] Client ${s} error:`,e),this.hub.stats.errors++,this.disconnectClient(s,"Connection error")}),this.sendToClient(s,{type:"data",data:{message:"Connected to LeaperFX WebSocket Hub",clientId:s,serverTime:Date.now()},timestamp:Date.now()}),this.logEvent({type:"connect",clientId:s,timestamp:Date.now()}),s}handleMessage(e,t){try{let s=JSON.parse(t),a=this.hub.clients.get(e);if(!a){console.warn(`[WebSocketHub] Message from unknown client: ${e}`);return}switch(a.lastActivity=Date.now(),this.hub.stats.messagesReceived++,console.log(`[WebSocketHub] Message from ${e}:`,s.type),s.type){case"subscribe":this.handleSubscribe(e,s);break;case"unsubscribe":this.handleUnsubscribe(e,s);break;case"ping":this.sendToClient(e,{type:"pong",timestamp:Date.now()});break;case"heartbeat":break;default:console.warn(`[WebSocketHub] Unknown message type: ${s.type}`),this.sendToClient(e,{type:"error",error:`Unknown message type: ${s.type}`,timestamp:Date.now()})}}catch(t){console.error(`[WebSocketHub] Error parsing message from ${e}:`,t),this.hub.stats.errors++,this.sendToClient(e,{type:"error",error:"Invalid message format",timestamp:Date.now()})}}handleSubscribe(e,t){let s=this.hub.clients.get(e);if(!s)return;let{symbols:a,subscriptionType:i,storeId:n,frequency:o}=t.data,c={symbols:a,clientId:e,storeId:n,lastActivity:Date.now(),subscriptionType:i};s.subscriptions.push(c),s.storeId=n,a.forEach(t=>{this.hub.subscriptions.has(t)||this.hub.subscriptions.set(t,new Set),this.hub.subscriptions.get(t).add(e)}),("rates"===i||"all"===i)&&r.Vy.subscribe(e),console.log(`[WebSocketHub] Client ${e} subscribed to ${a.join(", ")} (${i})`),this.sendToClient(e,{type:"data",data:{message:"Subscription successful",subscription:{symbols:a,subscriptionType:i,storeId:n}},timestamp:Date.now()}),this.sendInitialData(e,c),this.logEvent({type:"subscribe",clientId:e,storeId:n,data:{symbols:a,subscriptionType:i},timestamp:Date.now()})}handleUnsubscribe(e,t){let s=this.hub.clients.get(e);if(!s)return;let{symbols:a,subscriptionType:i,all:r}=t.data;r?this.removeAllSubscriptions(e):a&&(a.forEach(t=>{let s=this.hub.subscriptions.get(t);s&&(s.delete(e),0===s.size&&this.hub.subscriptions.delete(t))}),s.subscriptions=s.subscriptions.filter(e=>!a.some(t=>e.symbols.includes(t)))),console.log(`[WebSocketHub] Client ${e} unsubscribed`),this.sendToClient(e,{type:"data",data:{message:"Unsubscribed successfully"},timestamp:Date.now()}),this.logEvent({type:"unsubscribe",clientId:e,data:{symbols:a,subscriptionType:i,all:r},timestamp:Date.now()})}async sendInitialData(e,t){try{if("rates"===t.subscriptionType||"all"===t.subscriptionType){let s=r.Vy.getAllRates(),a=s.filter(e=>t.symbols.includes(`${e.baseCurrency}/${e.targetCurrency}`)||t.symbols.includes(`${e.baseCurrency}${e.targetCurrency}`));a.length>0&&this.sendToClient(e,{type:"data",data:{type:"initial_rates",rates:a},timestamp:Date.now()})}if("alerts"===t.subscriptionType||"all"===t.subscriptionType){let t=r.Vy.getAlerts(10);t.length>0&&this.sendToClient(e,{type:"data",data:{type:"initial_alerts",alerts:t},timestamp:Date.now()})}}catch(t){console.error(`[WebSocketHub] Error sending initial data to ${e}:`,t)}}broadcastRateUpdate(e){let t={type:"data",data:{symbol:"rates",update:{type:"rate_update",rates:e,timestamp:Date.now()},source:"rate_engine"},timestamp:Date.now()};this.broadcastToSubscribers("rates",t)}broadcastAlert(e){let t={type:"data",data:{symbol:"alerts",update:{type:"alert",alert:e,timestamp:Date.now()},source:"rate_engine"},timestamp:Date.now()};this.broadcastToSubscribers("alerts",t)}broadcastMarketData(e,t){let s={type:"data",data:{symbol:e,update:{type:"market_data",data:t,timestamp:Date.now()},source:"market_data"},timestamp:Date.now()};this.broadcastToSubscribers(e,s)}broadcastToSubscribers(e,t){let s=this.hub.subscriptions.get(e);if(s)for(let e of s)this.sendToClient(e,t)}sendToClient(e,t){let s=this.hub.clients.get(e);if(s&&s.isActive)try{let e=JSON.stringify(t);s.socket.send(e),this.hub.stats.messagesSent++}catch(t){console.error(`[WebSocketHub] Error sending to client ${e}:`,t),this.hub.stats.errors++,this.disconnectClient(e,"Send error")}}sendHeartbeat(){let e={type:"heartbeat",data:{serverTime:Date.now(),activeConnections:this.hub.stats.activeConnections,activeSubscriptions:this.hub.subscriptions.size},timestamp:Date.now()};for(let t of this.hub.clients.keys())this.sendToClient(t,e)}cleanupStaleConnections(){let e=Date.now();for(let[t,s]of this.hub.clients)e-s.lastActivity>3e5&&(console.log(`[WebSocketHub] Cleaning up stale connection: ${t}`),this.disconnectClient(t,"Stale connection"))}disconnectClient(e,t){let s=this.hub.clients.get(e);if(s){console.log(`[WebSocketHub] Disconnecting client ${e}: ${t}`),this.removeAllSubscriptions(e),r.Vy.unsubscribe(e);try{s.socket.readyState===s.socket.OPEN&&s.socket.close()}catch(t){console.error(`[WebSocketHub] Error closing socket for ${e}:`,t)}this.hub.clients.delete(e),this.hub.stats.activeConnections--,this.logEvent({type:"disconnect",clientId:e,data:{reason:t},timestamp:Date.now()})}}removeAllSubscriptions(e){for(let[t,s]of this.hub.subscriptions)s.delete(e),0===s.size&&this.hub.subscriptions.delete(t);let t=this.hub.clients.get(e);t&&(t.subscriptions=[])}getClientIP(e){let t=e.headers["x-forwarded-for"],s=e.headers["x-real-ip"];return"string"==typeof t?t.split(",")[0].trim():"string"==typeof s?s:e.socket.remoteAddress||"unknown"}logEvent(e){console.log(`[WebSocketHub] Event: ${e.type} - Client: ${e.clientId}`)}getStats(){return{...this.hub.stats,activeClients:this.hub.clients.size,activeSubscriptions:this.hub.subscriptions.size,subscriptionDetails:Array.from(this.hub.subscriptions.entries()).map(([e,t])=>({symbol:e,subscriberCount:t.size}))}}getClients(){return Array.from(this.hub.clients.values()).map(e=>({...e,socket:void 0}))}isRunning(){return this.hub.isRunning}}let c=o.getInstance();a()}catch(e){a(e)}})}};